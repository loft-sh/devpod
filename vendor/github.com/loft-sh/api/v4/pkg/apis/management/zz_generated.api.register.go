// Code generated by generator. DO NOT EDIT.

package management

import (
	"context"
	"fmt"

	pkglicenseapi "github.com/loft-sh/admin-apis/pkg/licenseapi"
	clusterv1 "github.com/loft-sh/agentapi/v4/pkg/apis/loft/cluster/v1"
	agentstoragev1 "github.com/loft-sh/agentapi/v4/pkg/apis/loft/storage/v1"
	auditv1 "github.com/loft-sh/api/v4/pkg/apis/audit/v1"
	storagev1 "github.com/loft-sh/api/v4/pkg/apis/storage/v1"
	uiv1 "github.com/loft-sh/api/v4/pkg/apis/ui/v1"
	"github.com/loft-sh/api/v4/pkg/managerfactory"
	"github.com/loft-sh/apiserver/pkg/builders"
	authorizationv1 "k8s.io/api/authorization/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/rest"
)

type NewRESTFunc func(factory managerfactory.SharedManagerFactory) rest.Storage

var (
	ManagementAgentAuditEventStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAgentAuditEvent,
		func() runtime.Object { return &AgentAuditEvent{} },     // Register versioned resource
		func() runtime.Object { return &AgentAuditEventList{} }, // Register versioned resource list
		NewAgentAuditEventsREST,
	)
	NewAgentAuditEventsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAgentAuditEventsRESTFunc(Factory)
	}
	NewAgentAuditEventsRESTFunc   NewRESTFunc
	ManagementAnnouncementStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAnnouncement,
		func() runtime.Object { return &Announcement{} },     // Register versioned resource
		func() runtime.Object { return &AnnouncementList{} }, // Register versioned resource list
		NewAnnouncementREST,
	)
	NewAnnouncementREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAnnouncementRESTFunc(Factory)
	}
	NewAnnouncementRESTFunc NewRESTFunc
	ManagementAppStorage    = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalApp,
		func() runtime.Object { return &App{} },     // Register versioned resource
		func() runtime.Object { return &AppList{} }, // Register versioned resource list
		NewAppREST,
	)
	NewAppREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAppRESTFunc(Factory)
	}
	NewAppRESTFunc          NewRESTFunc
	ManagementBackupStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalBackup,
		func() runtime.Object { return &Backup{} },     // Register versioned resource
		func() runtime.Object { return &BackupList{} }, // Register versioned resource list
		NewBackupREST,
	)
	NewBackupREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewBackupRESTFunc(Factory)
	}
	NewBackupRESTFunc        NewRESTFunc
	ManagementClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalCluster,
		func() runtime.Object { return &Cluster{} },     // Register versioned resource
		func() runtime.Object { return &ClusterList{} }, // Register versioned resource list
		NewClusterREST,
	)
	NewClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRESTFunc(Factory)
	}
	NewClusterRESTFunc   NewRESTFunc
	NewClusterStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterStatusRESTFunc(Factory)
	}
	NewClusterStatusRESTFunc       NewRESTFunc
	ManagementClusterAccessStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterAccess,
		func() runtime.Object { return &ClusterAccess{} },     // Register versioned resource
		func() runtime.Object { return &ClusterAccessList{} }, // Register versioned resource list
		NewClusterAccessREST,
	)
	NewClusterAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAccessRESTFunc(Factory)
	}
	NewClusterAccessRESTFunc             NewRESTFunc
	ManagementClusterRoleTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalClusterRoleTemplate,
		func() runtime.Object { return &ClusterRoleTemplate{} },     // Register versioned resource
		func() runtime.Object { return &ClusterRoleTemplateList{} }, // Register versioned resource list
		NewClusterRoleTemplateREST,
	)
	NewClusterRoleTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterRoleTemplateRESTFunc(Factory)
	}
	NewClusterRoleTemplateRESTFunc NewRESTFunc
	ManagementConfigStorage        = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalConfig,
		func() runtime.Object { return &Config{} },     // Register versioned resource
		func() runtime.Object { return &ConfigList{} }, // Register versioned resource list
		NewConfigREST,
	)
	NewConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewConfigRESTFunc(Factory)
	}
	NewConfigRESTFunc                            NewRESTFunc
	ManagementConvertVirtualClusterConfigStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalConvertVirtualClusterConfig,
		func() runtime.Object { return &ConvertVirtualClusterConfig{} },     // Register versioned resource
		func() runtime.Object { return &ConvertVirtualClusterConfigList{} }, // Register versioned resource list
		NewConvertVirtualClusterConfigREST,
	)
	NewConvertVirtualClusterConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewConvertVirtualClusterConfigRESTFunc(Factory)
	}
	NewConvertVirtualClusterConfigRESTFunc     NewRESTFunc
	ManagementDevPodEnvironmentTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodEnvironmentTemplate,
		func() runtime.Object { return &DevPodEnvironmentTemplate{} },     // Register versioned resource
		func() runtime.Object { return &DevPodEnvironmentTemplateList{} }, // Register versioned resource list
		NewDevPodEnvironmentTemplateREST,
	)
	NewDevPodEnvironmentTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodEnvironmentTemplateRESTFunc(Factory)
	}
	NewDevPodEnvironmentTemplateRESTFunc     NewRESTFunc
	ManagementDevPodWorkspaceInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodWorkspaceInstance,
		func() runtime.Object { return &DevPodWorkspaceInstance{} },     // Register versioned resource
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} }, // Register versioned resource list
		NewDevPodWorkspaceInstanceREST,
	)
	NewDevPodWorkspaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceRESTFunc     NewRESTFunc
	ManagementDevPodWorkspacePresetStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodWorkspacePreset,
		func() runtime.Object { return &DevPodWorkspacePreset{} },     // Register versioned resource
		func() runtime.Object { return &DevPodWorkspacePresetList{} }, // Register versioned resource list
		NewDevPodWorkspacePresetREST,
	)
	NewDevPodWorkspacePresetREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspacePresetRESTFunc(Factory)
	}
	NewDevPodWorkspacePresetRESTFunc         NewRESTFunc
	ManagementDevPodWorkspaceTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDevPodWorkspaceTemplate,
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },     // Register versioned resource
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} }, // Register versioned resource list
		NewDevPodWorkspaceTemplateREST,
	)
	NewDevPodWorkspaceTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceTemplateRESTFunc(Factory)
	}
	NewDevPodWorkspaceTemplateRESTFunc          NewRESTFunc
	ManagementDirectClusterEndpointTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalDirectClusterEndpointToken,
		func() runtime.Object { return &DirectClusterEndpointToken{} },     // Register versioned resource
		func() runtime.Object { return &DirectClusterEndpointTokenList{} }, // Register versioned resource list
		NewDirectClusterEndpointTokenREST,
	)
	NewDirectClusterEndpointTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDirectClusterEndpointTokenRESTFunc(Factory)
	}
	NewDirectClusterEndpointTokenRESTFunc NewRESTFunc
	ManagementEventStorage                = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalEvent,
		func() runtime.Object { return &Event{} },     // Register versioned resource
		func() runtime.Object { return &EventList{} }, // Register versioned resource list
		NewEventREST,
	)
	NewEventREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewEventRESTFunc(Factory)
	}
	NewEventRESTFunc         NewRESTFunc
	ManagementFeatureStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalFeature,
		func() runtime.Object { return &Feature{} },     // Register versioned resource
		func() runtime.Object { return &FeatureList{} }, // Register versioned resource list
		NewFeatureREST,
	)
	NewFeatureREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewFeatureRESTFunc(Factory)
	}
	NewFeatureRESTFunc   NewRESTFunc
	NewFeatureStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewFeatureStatusRESTFunc(Factory)
	}
	NewFeatureStatusRESTFunc          NewRESTFunc
	ManagementIngressAuthTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalIngressAuthToken,
		func() runtime.Object { return &IngressAuthToken{} },     // Register versioned resource
		func() runtime.Object { return &IngressAuthTokenList{} }, // Register versioned resource list
		NewIngressAuthTokenREST,
	)
	NewIngressAuthTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewIngressAuthTokenRESTFunc(Factory)
	}
	NewIngressAuthTokenRESTFunc NewRESTFunc
	ManagementKioskStorage      = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalKiosk,
		func() runtime.Object { return &Kiosk{} },     // Register versioned resource
		func() runtime.Object { return &KioskList{} }, // Register versioned resource list
		NewKioskREST,
	)
	NewKioskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewKioskRESTFunc(Factory)
	}
	NewKioskRESTFunc         NewRESTFunc
	ManagementLicenseStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicense,
		func() runtime.Object { return &License{} },     // Register versioned resource
		func() runtime.Object { return &LicenseList{} }, // Register versioned resource list
		NewLicenseREST,
	)
	NewLicenseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRESTFunc(Factory)
	}
	NewLicenseRESTFunc            NewRESTFunc
	ManagementLicenseTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLicenseToken,
		func() runtime.Object { return &LicenseToken{} },     // Register versioned resource
		func() runtime.Object { return &LicenseTokenList{} }, // Register versioned resource list
		NewLicenseTokenREST,
	)
	NewLicenseTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseTokenRESTFunc(Factory)
	}
	NewLicenseTokenRESTFunc      NewRESTFunc
	ManagementLoftUpgradeStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalLoftUpgrade,
		func() runtime.Object { return &LoftUpgrade{} },     // Register versioned resource
		func() runtime.Object { return &LoftUpgradeList{} }, // Register versioned resource list
		NewLoftUpgradeREST,
	)
	NewLoftUpgradeREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLoftUpgradeRESTFunc(Factory)
	}
	NewLoftUpgradeRESTFunc      NewRESTFunc
	ManagementOIDCClientStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalOIDCClient,
		func() runtime.Object { return &OIDCClient{} },     // Register versioned resource
		func() runtime.Object { return &OIDCClientList{} }, // Register versioned resource list
		NewOIDCClientREST,
	)
	NewOIDCClientREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewOIDCClientRESTFunc(Factory)
	}
	NewOIDCClientRESTFunc           NewRESTFunc
	ManagementOwnedAccessKeyStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalOwnedAccessKey,
		func() runtime.Object { return &OwnedAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &OwnedAccessKeyList{} }, // Register versioned resource list
		NewOwnedAccessKeyREST,
	)
	NewOwnedAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewOwnedAccessKeyRESTFunc(Factory)
	}
	NewOwnedAccessKeyRESTFunc NewRESTFunc
	ManagementProjectStorage  = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalProject,
		func() runtime.Object { return &Project{} },     // Register versioned resource
		func() runtime.Object { return &ProjectList{} }, // Register versioned resource list
		NewProjectREST,
	)
	NewProjectREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectRESTFunc(Factory)
	}
	NewProjectRESTFunc   NewRESTFunc
	NewProjectStatusREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectStatusRESTFunc(Factory)
	}
	NewProjectStatusRESTFunc       NewRESTFunc
	ManagementProjectSecretStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalProjectSecret,
		func() runtime.Object { return &ProjectSecret{} },     // Register versioned resource
		func() runtime.Object { return &ProjectSecretList{} }, // Register versioned resource list
		NewProjectSecretREST,
	)
	NewProjectSecretREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectSecretRESTFunc(Factory)
	}
	NewProjectSecretRESTFunc       NewRESTFunc
	ManagementRedirectTokenStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalRedirectToken,
		func() runtime.Object { return &RedirectToken{} },     // Register versioned resource
		func() runtime.Object { return &RedirectTokenList{} }, // Register versioned resource list
		NewRedirectTokenREST,
	)
	NewRedirectTokenREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRedirectTokenRESTFunc(Factory)
	}
	NewRedirectTokenRESTFunc                NewRESTFunc
	ManagementRegisterVirtualClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalRegisterVirtualCluster,
		func() runtime.Object { return &RegisterVirtualCluster{} },     // Register versioned resource
		func() runtime.Object { return &RegisterVirtualClusterList{} }, // Register versioned resource list
		NewRegisterVirtualClusterREST,
	)
	NewRegisterVirtualClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewRegisterVirtualClusterRESTFunc(Factory)
	}
	NewRegisterVirtualClusterRESTFunc NewRESTFunc
	ManagementResetAccessKeyStorage   = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalResetAccessKey,
		func() runtime.Object { return &ResetAccessKey{} },     // Register versioned resource
		func() runtime.Object { return &ResetAccessKeyList{} }, // Register versioned resource list
		NewResetAccessKeyREST,
	)
	NewResetAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewResetAccessKeyRESTFunc(Factory)
	}
	NewResetAccessKeyRESTFunc NewRESTFunc
	ManagementSelfStorage     = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelf,
		func() runtime.Object { return &Self{} },     // Register versioned resource
		func() runtime.Object { return &SelfList{} }, // Register versioned resource list
		NewSelfREST,
	)
	NewSelfREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfRESTFunc(Factory)
	}
	NewSelfRESTFunc                          NewRESTFunc
	ManagementSelfSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSelfSubjectAccessReview,
		func() runtime.Object { return &SelfSubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SelfSubjectAccessReviewList{} }, // Register versioned resource list
		NewSelfSubjectAccessReviewREST,
	)
	NewSelfSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSelfSubjectAccessReviewRESTFunc(Factory)
	}
	NewSelfSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementSharedSecretStorage      = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSharedSecret,
		func() runtime.Object { return &SharedSecret{} },     // Register versioned resource
		func() runtime.Object { return &SharedSecretList{} }, // Register versioned resource list
		NewSharedSecretREST,
	)
	NewSharedSecretREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSharedSecretRESTFunc(Factory)
	}
	NewSharedSecretRESTFunc        NewRESTFunc
	ManagementSpaceInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceInstance,
		func() runtime.Object { return &SpaceInstance{} },     // Register versioned resource
		func() runtime.Object { return &SpaceInstanceList{} }, // Register versioned resource list
		NewSpaceInstanceREST,
	)
	NewSpaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceInstanceRESTFunc(Factory)
	}
	NewSpaceInstanceRESTFunc       NewRESTFunc
	ManagementSpaceTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSpaceTemplate,
		func() runtime.Object { return &SpaceTemplate{} },     // Register versioned resource
		func() runtime.Object { return &SpaceTemplateList{} }, // Register versioned resource list
		NewSpaceTemplateREST,
	)
	NewSpaceTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSpaceTemplateRESTFunc(Factory)
	}
	NewSpaceTemplateRESTFunc             NewRESTFunc
	ManagementSubjectAccessReviewStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSubjectAccessReview,
		func() runtime.Object { return &SubjectAccessReview{} },     // Register versioned resource
		func() runtime.Object { return &SubjectAccessReviewList{} }, // Register versioned resource list
		NewSubjectAccessReviewREST,
	)
	NewSubjectAccessReviewREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSubjectAccessReviewRESTFunc(Factory)
	}
	NewSubjectAccessReviewRESTFunc NewRESTFunc
	ManagementTaskStorage          = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTask,
		func() runtime.Object { return &Task{} },     // Register versioned resource
		func() runtime.Object { return &TaskList{} }, // Register versioned resource list
		NewTaskREST,
	)
	NewTaskREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskRESTFunc(Factory)
	}
	NewTaskRESTFunc       NewRESTFunc
	ManagementTeamStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTeam,
		func() runtime.Object { return &Team{} },     // Register versioned resource
		func() runtime.Object { return &TeamList{} }, // Register versioned resource list
		NewTeamREST,
	)
	NewTeamREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamRESTFunc(Factory)
	}
	NewTeamRESTFunc                                NewRESTFunc
	ManagementTranslateVClusterResourceNameStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalTranslateVClusterResourceName,
		func() runtime.Object { return &TranslateVClusterResourceName{} },     // Register versioned resource
		func() runtime.Object { return &TranslateVClusterResourceNameList{} }, // Register versioned resource list
		NewTranslateVClusterResourceNameREST,
	)
	NewTranslateVClusterResourceNameREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTranslateVClusterResourceNameRESTFunc(Factory)
	}
	NewTranslateVClusterResourceNameRESTFunc NewRESTFunc
	ManagementUserStorage                    = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalUser,
		func() runtime.Object { return &User{} },     // Register versioned resource
		func() runtime.Object { return &UserList{} }, // Register versioned resource list
		NewUserREST,
	)
	NewUserREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserRESTFunc(Factory)
	}
	NewUserRESTFunc                         NewRESTFunc
	ManagementVirtualClusterInstanceStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterInstance,
		func() runtime.Object { return &VirtualClusterInstance{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterInstanceList{} }, // Register versioned resource list
		NewVirtualClusterInstanceREST,
	)
	NewVirtualClusterInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceRESTFunc(Factory)
	}
	NewVirtualClusterInstanceRESTFunc     NewRESTFunc
	ManagementVirtualClusterSchemaStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterSchema,
		func() runtime.Object { return &VirtualClusterSchema{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterSchemaList{} }, // Register versioned resource list
		NewVirtualClusterSchemaREST,
	)
	NewVirtualClusterSchemaREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterSchemaRESTFunc(Factory)
	}
	NewVirtualClusterSchemaRESTFunc         NewRESTFunc
	ManagementVirtualClusterTemplateStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualClusterTemplate,
		func() runtime.Object { return &VirtualClusterTemplate{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterTemplateList{} }, // Register versioned resource list
		NewVirtualClusterTemplateREST,
	)
	NewVirtualClusterTemplateREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterTemplateRESTFunc(Factory)
	}
	NewVirtualClusterTemplateRESTFunc NewRESTFunc
	InternalAgentAuditEvent           = builders.NewInternalResource(
		"agentauditevents",
		"AgentAuditEvent",
		func() runtime.Object { return &AgentAuditEvent{} },
		func() runtime.Object { return &AgentAuditEventList{} },
	)
	InternalAgentAuditEventStatus = builders.NewInternalResourceStatus(
		"agentauditevents",
		"AgentAuditEventStatus",
		func() runtime.Object { return &AgentAuditEvent{} },
		func() runtime.Object { return &AgentAuditEventList{} },
	)
	InternalAnnouncement = builders.NewInternalResource(
		"announcements",
		"Announcement",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalAnnouncementStatus = builders.NewInternalResourceStatus(
		"announcements",
		"AnnouncementStatus",
		func() runtime.Object { return &Announcement{} },
		func() runtime.Object { return &AnnouncementList{} },
	)
	InternalApp = builders.NewInternalResource(
		"apps",
		"App",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalAppStatus = builders.NewInternalResourceStatus(
		"apps",
		"AppStatus",
		func() runtime.Object { return &App{} },
		func() runtime.Object { return &AppList{} },
	)
	InternalAppCredentialsREST = builders.NewInternalSubresource(
		"apps", "AppCredentials", "credentials",
		func() runtime.Object { return &AppCredentials{} },
	)
	NewAppCredentialsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAppCredentialsRESTFunc(Factory)
	}
	NewAppCredentialsRESTFunc NewRESTFunc
	InternalBackup            = builders.NewInternalResource(
		"backups",
		"Backup",
		func() runtime.Object { return &Backup{} },
		func() runtime.Object { return &BackupList{} },
	)
	InternalBackupStatus = builders.NewInternalResourceStatus(
		"backups",
		"BackupStatus",
		func() runtime.Object { return &Backup{} },
		func() runtime.Object { return &BackupList{} },
	)
	InternalBackupApplyREST = builders.NewInternalSubresource(
		"backups", "BackupApply", "apply",
		func() runtime.Object { return &BackupApply{} },
	)
	NewBackupApplyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewBackupApplyRESTFunc(Factory)
	}
	NewBackupApplyRESTFunc NewRESTFunc
	InternalCluster        = builders.NewInternalResource(
		"clusters",
		"Cluster",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterStatus = builders.NewInternalResourceStatus(
		"clusters",
		"ClusterStatus",
		func() runtime.Object { return &Cluster{} },
		func() runtime.Object { return &ClusterList{} },
	)
	InternalClusterAccessKeyREST = builders.NewInternalSubresource(
		"clusters", "ClusterAccessKey", "accesskey",
		func() runtime.Object { return &ClusterAccessKey{} },
	)
	NewClusterAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAccessKeyRESTFunc(Factory)
	}
	NewClusterAccessKeyRESTFunc    NewRESTFunc
	InternalClusterAgentConfigREST = builders.NewInternalSubresource(
		"clusters", "ClusterAgentConfig", "agentconfig",
		func() runtime.Object { return &ClusterAgentConfig{} },
	)
	NewClusterAgentConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterAgentConfigRESTFunc(Factory)
	}
	NewClusterAgentConfigRESTFunc NewRESTFunc
	InternalClusterChartsREST     = builders.NewInternalSubresource(
		"clusters", "ClusterCharts", "charts",
		func() runtime.Object { return &ClusterCharts{} },
	)
	NewClusterChartsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterChartsRESTFunc(Factory)
	}
	NewClusterChartsRESTFunc  NewRESTFunc
	InternalClusterDomainREST = builders.NewInternalSubresource(
		"clusters", "ClusterDomain", "domain",
		func() runtime.Object { return &ClusterDomain{} },
	)
	NewClusterDomainREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterDomainRESTFunc(Factory)
	}
	NewClusterDomainRESTFunc        NewRESTFunc
	InternalClusterMemberAccessREST = builders.NewInternalSubresource(
		"clusters", "ClusterMemberAccess", "memberaccess",
		func() runtime.Object { return &ClusterMemberAccess{} },
	)
	NewClusterMemberAccessREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMemberAccessRESTFunc(Factory)
	}
	NewClusterMemberAccessRESTFunc NewRESTFunc
	InternalClusterMembersREST     = builders.NewInternalSubresource(
		"clusters", "ClusterMembers", "members",
		func() runtime.Object { return &ClusterMembers{} },
	)
	NewClusterMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterMembersRESTFunc(Factory)
	}
	NewClusterMembersRESTFunc NewRESTFunc
	InternalClusterResetREST  = builders.NewInternalSubresource(
		"clusters", "ClusterReset", "reset",
		func() runtime.Object { return &ClusterReset{} },
	)
	NewClusterResetREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterResetRESTFunc(Factory)
	}
	NewClusterResetRESTFunc                   NewRESTFunc
	InternalClusterVirtualClusterDefaultsREST = builders.NewInternalSubresource(
		"clusters", "ClusterVirtualClusterDefaults", "virtualclusterdefaults",
		func() runtime.Object { return &ClusterVirtualClusterDefaults{} },
	)
	NewClusterVirtualClusterDefaultsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewClusterVirtualClusterDefaultsRESTFunc(Factory)
	}
	NewClusterVirtualClusterDefaultsRESTFunc NewRESTFunc
	InternalClusterAccess                    = builders.NewInternalResource(
		"clusteraccesses",
		"ClusterAccess",
		func() runtime.Object { return &ClusterAccess{} },
		func() runtime.Object { return &ClusterAccessList{} },
	)
	InternalClusterAccessStatus = builders.NewInternalResourceStatus(
		"clusteraccesses",
		"ClusterAccessStatus",
		func() runtime.Object { return &ClusterAccess{} },
		func() runtime.Object { return &ClusterAccessList{} },
	)
	InternalClusterRoleTemplate = builders.NewInternalResource(
		"clusterroletemplates",
		"ClusterRoleTemplate",
		func() runtime.Object { return &ClusterRoleTemplate{} },
		func() runtime.Object { return &ClusterRoleTemplateList{} },
	)
	InternalClusterRoleTemplateStatus = builders.NewInternalResourceStatus(
		"clusterroletemplates",
		"ClusterRoleTemplateStatus",
		func() runtime.Object { return &ClusterRoleTemplate{} },
		func() runtime.Object { return &ClusterRoleTemplateList{} },
	)
	InternalConfig = builders.NewInternalResource(
		"configs",
		"Config",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalConfigStatus = builders.NewInternalResourceStatus(
		"configs",
		"ConfigStatus",
		func() runtime.Object { return &Config{} },
		func() runtime.Object { return &ConfigList{} },
	)
	InternalConvertVirtualClusterConfig = builders.NewInternalResource(
		"convertvirtualclusterconfig",
		"ConvertVirtualClusterConfig",
		func() runtime.Object { return &ConvertVirtualClusterConfig{} },
		func() runtime.Object { return &ConvertVirtualClusterConfigList{} },
	)
	InternalConvertVirtualClusterConfigStatus = builders.NewInternalResourceStatus(
		"convertvirtualclusterconfig",
		"ConvertVirtualClusterConfigStatus",
		func() runtime.Object { return &ConvertVirtualClusterConfig{} },
		func() runtime.Object { return &ConvertVirtualClusterConfigList{} },
	)
	InternalDevPodEnvironmentTemplate = builders.NewInternalResource(
		"devpodenvironmenttemplates",
		"DevPodEnvironmentTemplate",
		func() runtime.Object { return &DevPodEnvironmentTemplate{} },
		func() runtime.Object { return &DevPodEnvironmentTemplateList{} },
	)
	InternalDevPodEnvironmentTemplateStatus = builders.NewInternalResourceStatus(
		"devpodenvironmenttemplates",
		"DevPodEnvironmentTemplateStatus",
		func() runtime.Object { return &DevPodEnvironmentTemplate{} },
		func() runtime.Object { return &DevPodEnvironmentTemplateList{} },
	)
	InternalDevPodWorkspaceInstance = builders.NewInternalResource(
		"devpodworkspaceinstances",
		"DevPodWorkspaceInstance",
		func() runtime.Object { return &DevPodWorkspaceInstance{} },
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} },
	)
	InternalDevPodWorkspaceInstanceStatus = builders.NewInternalResourceStatus(
		"devpodworkspaceinstances",
		"DevPodWorkspaceInstanceStatus",
		func() runtime.Object { return &DevPodWorkspaceInstance{} },
		func() runtime.Object { return &DevPodWorkspaceInstanceList{} },
	)
	InternalDevPodWorkspaceInstanceCancelREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceCancel", "cancel",
		func() runtime.Object { return &DevPodWorkspaceInstanceCancel{} },
	)
	NewDevPodWorkspaceInstanceCancelREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceCancelRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceCancelRESTFunc    NewRESTFunc
	InternalDevPodWorkspaceInstanceDownloadREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceDownload", "download",
		func() runtime.Object { return &DevPodWorkspaceInstanceDownload{} },
	)
	NewDevPodWorkspaceInstanceDownloadREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceDownloadRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceDownloadRESTFunc NewRESTFunc
	InternalDevPodWorkspaceInstanceLogREST     = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceLog", "log",
		func() runtime.Object { return &DevPodWorkspaceInstanceLog{} },
	)
	NewDevPodWorkspaceInstanceLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceLogRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceLogRESTFunc   NewRESTFunc
	InternalDevPodWorkspaceInstanceStopREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceStop", "stop",
		func() runtime.Object { return &DevPodWorkspaceInstanceStop{} },
	)
	NewDevPodWorkspaceInstanceStopREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceStopRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceStopRESTFunc   NewRESTFunc
	InternalDevPodWorkspaceInstanceTasksREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceTasks", "tasks",
		func() runtime.Object { return &DevPodWorkspaceInstanceTasks{} },
	)
	NewDevPodWorkspaceInstanceTasksREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceTasksRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceTasksRESTFunc         NewRESTFunc
	InternalDevPodWorkspaceInstanceTroubleshootREST = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceTroubleshoot", "troubleshoot",
		func() runtime.Object { return &DevPodWorkspaceInstanceTroubleshoot{} },
	)
	NewDevPodWorkspaceInstanceTroubleshootREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceTroubleshootRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceTroubleshootRESTFunc NewRESTFunc
	InternalDevPodWorkspaceInstanceUpREST          = builders.NewInternalSubresource(
		"devpodworkspaceinstances", "DevPodWorkspaceInstanceUp", "up",
		func() runtime.Object { return &DevPodWorkspaceInstanceUp{} },
	)
	NewDevPodWorkspaceInstanceUpREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewDevPodWorkspaceInstanceUpRESTFunc(Factory)
	}
	NewDevPodWorkspaceInstanceUpRESTFunc NewRESTFunc
	InternalDevPodWorkspacePreset        = builders.NewInternalResource(
		"devpodworkspacepresets",
		"DevPodWorkspacePreset",
		func() runtime.Object { return &DevPodWorkspacePreset{} },
		func() runtime.Object { return &DevPodWorkspacePresetList{} },
	)
	InternalDevPodWorkspacePresetStatus = builders.NewInternalResourceStatus(
		"devpodworkspacepresets",
		"DevPodWorkspacePresetStatus",
		func() runtime.Object { return &DevPodWorkspacePreset{} },
		func() runtime.Object { return &DevPodWorkspacePresetList{} },
	)
	InternalDevPodWorkspaceTemplate = builders.NewInternalResource(
		"devpodworkspacetemplates",
		"DevPodWorkspaceTemplate",
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} },
	)
	InternalDevPodWorkspaceTemplateStatus = builders.NewInternalResourceStatus(
		"devpodworkspacetemplates",
		"DevPodWorkspaceTemplateStatus",
		func() runtime.Object { return &DevPodWorkspaceTemplate{} },
		func() runtime.Object { return &DevPodWorkspaceTemplateList{} },
	)
	InternalDirectClusterEndpointToken = builders.NewInternalResource(
		"directclusterendpointtokens",
		"DirectClusterEndpointToken",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalDirectClusterEndpointTokenStatus = builders.NewInternalResourceStatus(
		"directclusterendpointtokens",
		"DirectClusterEndpointTokenStatus",
		func() runtime.Object { return &DirectClusterEndpointToken{} },
		func() runtime.Object { return &DirectClusterEndpointTokenList{} },
	)
	InternalEvent = builders.NewInternalResource(
		"events",
		"Event",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalEventStatus = builders.NewInternalResourceStatus(
		"events",
		"EventStatus",
		func() runtime.Object { return &Event{} },
		func() runtime.Object { return &EventList{} },
	)
	InternalFeature = builders.NewInternalResource(
		"features",
		"Feature",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalFeatureStatus = builders.NewInternalResourceStatus(
		"features",
		"FeatureStatus",
		func() runtime.Object { return &Feature{} },
		func() runtime.Object { return &FeatureList{} },
	)
	InternalIngressAuthToken = builders.NewInternalResource(
		"ingressauthtokens",
		"IngressAuthToken",
		func() runtime.Object { return &IngressAuthToken{} },
		func() runtime.Object { return &IngressAuthTokenList{} },
	)
	InternalIngressAuthTokenStatus = builders.NewInternalResourceStatus(
		"ingressauthtokens",
		"IngressAuthTokenStatus",
		func() runtime.Object { return &IngressAuthToken{} },
		func() runtime.Object { return &IngressAuthTokenList{} },
	)
	InternalKiosk = builders.NewInternalResource(
		"kiosk",
		"Kiosk",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalKioskStatus = builders.NewInternalResourceStatus(
		"kiosk",
		"KioskStatus",
		func() runtime.Object { return &Kiosk{} },
		func() runtime.Object { return &KioskList{} },
	)
	InternalLicense = builders.NewInternalResource(
		"licenses",
		"License",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseStatus = builders.NewInternalResourceStatus(
		"licenses",
		"LicenseStatus",
		func() runtime.Object { return &License{} },
		func() runtime.Object { return &LicenseList{} },
	)
	InternalLicenseRequestREST = builders.NewInternalSubresource(
		"licenses", "LicenseRequest", "request",
		func() runtime.Object { return &LicenseRequest{} },
	)
	NewLicenseRequestREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewLicenseRequestRESTFunc(Factory)
	}
	NewLicenseRequestRESTFunc NewRESTFunc
	InternalLicenseToken      = builders.NewInternalResource(
		"licensetokens",
		"LicenseToken",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLicenseTokenStatus = builders.NewInternalResourceStatus(
		"licensetokens",
		"LicenseTokenStatus",
		func() runtime.Object { return &LicenseToken{} },
		func() runtime.Object { return &LicenseTokenList{} },
	)
	InternalLoftUpgrade = builders.NewInternalResource(
		"loftupgrades",
		"LoftUpgrade",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalLoftUpgradeStatus = builders.NewInternalResourceStatus(
		"loftupgrades",
		"LoftUpgradeStatus",
		func() runtime.Object { return &LoftUpgrade{} },
		func() runtime.Object { return &LoftUpgradeList{} },
	)
	InternalOIDCClient = builders.NewInternalResource(
		"oidcclients",
		"OIDCClient",
		func() runtime.Object { return &OIDCClient{} },
		func() runtime.Object { return &OIDCClientList{} },
	)
	InternalOIDCClientStatus = builders.NewInternalResourceStatus(
		"oidcclients",
		"OIDCClientStatus",
		func() runtime.Object { return &OIDCClient{} },
		func() runtime.Object { return &OIDCClientList{} },
	)
	InternalOwnedAccessKey = builders.NewInternalResource(
		"ownedaccesskeys",
		"OwnedAccessKey",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalOwnedAccessKeyStatus = builders.NewInternalResourceStatus(
		"ownedaccesskeys",
		"OwnedAccessKeyStatus",
		func() runtime.Object { return &OwnedAccessKey{} },
		func() runtime.Object { return &OwnedAccessKeyList{} },
	)
	InternalProject = builders.NewInternalResource(
		"projects",
		"Project",
		func() runtime.Object { return &Project{} },
		func() runtime.Object { return &ProjectList{} },
	)
	InternalProjectStatus = builders.NewInternalResourceStatus(
		"projects",
		"ProjectStatus",
		func() runtime.Object { return &Project{} },
		func() runtime.Object { return &ProjectList{} },
	)
	InternalProjectChartInfoREST = builders.NewInternalSubresource(
		"projects", "ProjectChartInfo", "chartinfo",
		func() runtime.Object { return &ProjectChartInfo{} },
	)
	NewProjectChartInfoREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectChartInfoRESTFunc(Factory)
	}
	NewProjectChartInfoRESTFunc NewRESTFunc
	InternalProjectChartsREST   = builders.NewInternalSubresource(
		"projects", "ProjectCharts", "charts",
		func() runtime.Object { return &ProjectCharts{} },
	)
	NewProjectChartsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectChartsRESTFunc(Factory)
	}
	NewProjectChartsRESTFunc    NewRESTFunc
	InternalProjectClustersREST = builders.NewInternalSubresource(
		"projects", "ProjectClusters", "clusters",
		func() runtime.Object { return &ProjectClusters{} },
	)
	NewProjectClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectClustersRESTFunc(Factory)
	}
	NewProjectClustersRESTFunc     NewRESTFunc
	InternalProjectImportSpaceREST = builders.NewInternalSubresource(
		"projects", "ProjectImportSpace", "importspace",
		func() runtime.Object { return &ProjectImportSpace{} },
	)
	NewProjectImportSpaceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectImportSpaceRESTFunc(Factory)
	}
	NewProjectImportSpaceRESTFunc NewRESTFunc
	InternalProjectMembersREST    = builders.NewInternalSubresource(
		"projects", "ProjectMembers", "members",
		func() runtime.Object { return &ProjectMembers{} },
	)
	NewProjectMembersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMembersRESTFunc(Factory)
	}
	NewProjectMembersRESTFunc               NewRESTFunc
	InternalProjectMigrateSpaceInstanceREST = builders.NewInternalSubresource(
		"projects", "ProjectMigrateSpaceInstance", "migratespaceinstance",
		func() runtime.Object { return &ProjectMigrateSpaceInstance{} },
	)
	NewProjectMigrateSpaceInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMigrateSpaceInstanceRESTFunc(Factory)
	}
	NewProjectMigrateSpaceInstanceRESTFunc           NewRESTFunc
	InternalProjectMigrateVirtualClusterInstanceREST = builders.NewInternalSubresource(
		"projects", "ProjectMigrateVirtualClusterInstance", "migratevirtualclusterinstance",
		func() runtime.Object { return &ProjectMigrateVirtualClusterInstance{} },
	)
	NewProjectMigrateVirtualClusterInstanceREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectMigrateVirtualClusterInstanceRESTFunc(Factory)
	}
	NewProjectMigrateVirtualClusterInstanceRESTFunc NewRESTFunc
	InternalProjectTemplatesREST                    = builders.NewInternalSubresource(
		"projects", "ProjectTemplates", "templates",
		func() runtime.Object { return &ProjectTemplates{} },
	)
	NewProjectTemplatesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewProjectTemplatesRESTFunc(Factory)
	}
	NewProjectTemplatesRESTFunc NewRESTFunc
	InternalProjectSecret       = builders.NewInternalResource(
		"projectsecrets",
		"ProjectSecret",
		func() runtime.Object { return &ProjectSecret{} },
		func() runtime.Object { return &ProjectSecretList{} },
	)
	InternalProjectSecretStatus = builders.NewInternalResourceStatus(
		"projectsecrets",
		"ProjectSecretStatus",
		func() runtime.Object { return &ProjectSecret{} },
		func() runtime.Object { return &ProjectSecretList{} },
	)
	InternalRedirectToken = builders.NewInternalResource(
		"redirecttokens",
		"RedirectToken",
		func() runtime.Object { return &RedirectToken{} },
		func() runtime.Object { return &RedirectTokenList{} },
	)
	InternalRedirectTokenStatus = builders.NewInternalResourceStatus(
		"redirecttokens",
		"RedirectTokenStatus",
		func() runtime.Object { return &RedirectToken{} },
		func() runtime.Object { return &RedirectTokenList{} },
	)
	InternalRegisterVirtualCluster = builders.NewInternalResource(
		"registervirtualclusters",
		"RegisterVirtualCluster",
		func() runtime.Object { return &RegisterVirtualCluster{} },
		func() runtime.Object { return &RegisterVirtualClusterList{} },
	)
	InternalRegisterVirtualClusterStatus = builders.NewInternalResourceStatus(
		"registervirtualclusters",
		"RegisterVirtualClusterStatus",
		func() runtime.Object { return &RegisterVirtualCluster{} },
		func() runtime.Object { return &RegisterVirtualClusterList{} },
	)
	InternalResetAccessKey = builders.NewInternalResource(
		"resetaccesskeys",
		"ResetAccessKey",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalResetAccessKeyStatus = builders.NewInternalResourceStatus(
		"resetaccesskeys",
		"ResetAccessKeyStatus",
		func() runtime.Object { return &ResetAccessKey{} },
		func() runtime.Object { return &ResetAccessKeyList{} },
	)
	InternalSelf = builders.NewInternalResource(
		"selves",
		"Self",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfStatus = builders.NewInternalResourceStatus(
		"selves",
		"SelfStatus",
		func() runtime.Object { return &Self{} },
		func() runtime.Object { return &SelfList{} },
	)
	InternalSelfSubjectAccessReview = builders.NewInternalResource(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReview",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSelfSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"selfsubjectaccessreviews",
		"SelfSubjectAccessReviewStatus",
		func() runtime.Object { return &SelfSubjectAccessReview{} },
		func() runtime.Object { return &SelfSubjectAccessReviewList{} },
	)
	InternalSharedSecret = builders.NewInternalResource(
		"sharedsecrets",
		"SharedSecret",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSharedSecretStatus = builders.NewInternalResourceStatus(
		"sharedsecrets",
		"SharedSecretStatus",
		func() runtime.Object { return &SharedSecret{} },
		func() runtime.Object { return &SharedSecretList{} },
	)
	InternalSpaceInstance = builders.NewInternalResource(
		"spaceinstances",
		"SpaceInstance",
		func() runtime.Object { return &SpaceInstance{} },
		func() runtime.Object { return &SpaceInstanceList{} },
	)
	InternalSpaceInstanceStatus = builders.NewInternalResourceStatus(
		"spaceinstances",
		"SpaceInstanceStatus",
		func() runtime.Object { return &SpaceInstance{} },
		func() runtime.Object { return &SpaceInstanceList{} },
	)
	InternalSpaceTemplate = builders.NewInternalResource(
		"spacetemplates",
		"SpaceTemplate",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSpaceTemplateStatus = builders.NewInternalResourceStatus(
		"spacetemplates",
		"SpaceTemplateStatus",
		func() runtime.Object { return &SpaceTemplate{} },
		func() runtime.Object { return &SpaceTemplateList{} },
	)
	InternalSubjectAccessReview = builders.NewInternalResource(
		"subjectaccessreviews",
		"SubjectAccessReview",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalSubjectAccessReviewStatus = builders.NewInternalResourceStatus(
		"subjectaccessreviews",
		"SubjectAccessReviewStatus",
		func() runtime.Object { return &SubjectAccessReview{} },
		func() runtime.Object { return &SubjectAccessReviewList{} },
	)
	InternalTask = builders.NewInternalResource(
		"tasks",
		"Task",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskStatus = builders.NewInternalResourceStatus(
		"tasks",
		"TaskStatus",
		func() runtime.Object { return &Task{} },
		func() runtime.Object { return &TaskList{} },
	)
	InternalTaskLogREST = builders.NewInternalSubresource(
		"tasks", "TaskLog", "log",
		func() runtime.Object { return &TaskLog{} },
	)
	NewTaskLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTaskLogRESTFunc(Factory)
	}
	NewTaskLogRESTFunc NewRESTFunc
	InternalTeam       = builders.NewInternalResource(
		"teams",
		"Team",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamStatus = builders.NewInternalResourceStatus(
		"teams",
		"TeamStatus",
		func() runtime.Object { return &Team{} },
		func() runtime.Object { return &TeamList{} },
	)
	InternalTeamAccessKeysREST = builders.NewInternalSubresource(
		"teams", "TeamAccessKeys", "accesskeys",
		func() runtime.Object { return &TeamAccessKeys{} },
	)
	NewTeamAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamAccessKeysRESTFunc(Factory)
	}
	NewTeamAccessKeysRESTFunc NewRESTFunc
	InternalTeamClustersREST  = builders.NewInternalSubresource(
		"teams", "TeamClusters", "clusters",
		func() runtime.Object { return &TeamClusters{} },
	)
	NewTeamClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamClustersRESTFunc(Factory)
	}
	NewTeamClustersRESTFunc           NewRESTFunc
	InternalTeamObjectPermissionsREST = builders.NewInternalSubresource(
		"teams", "TeamObjectPermissions", "object-permissions",
		func() runtime.Object { return &TeamObjectPermissions{} },
	)
	NewTeamObjectPermissionsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamObjectPermissionsRESTFunc(Factory)
	}
	NewTeamObjectPermissionsRESTFunc NewRESTFunc
	InternalTeamPermissionsREST      = builders.NewInternalSubresource(
		"teams", "TeamPermissions", "permissions",
		func() runtime.Object { return &TeamPermissions{} },
	)
	NewTeamPermissionsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewTeamPermissionsRESTFunc(Factory)
	}
	NewTeamPermissionsRESTFunc            NewRESTFunc
	InternalTranslateVClusterResourceName = builders.NewInternalResource(
		"translatevclusterresourcenames",
		"TranslateVClusterResourceName",
		func() runtime.Object { return &TranslateVClusterResourceName{} },
		func() runtime.Object { return &TranslateVClusterResourceNameList{} },
	)
	InternalTranslateVClusterResourceNameStatus = builders.NewInternalResourceStatus(
		"translatevclusterresourcenames",
		"TranslateVClusterResourceNameStatus",
		func() runtime.Object { return &TranslateVClusterResourceName{} },
		func() runtime.Object { return &TranslateVClusterResourceNameList{} },
	)
	InternalUser = builders.NewInternalResource(
		"users",
		"User",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserStatus = builders.NewInternalResourceStatus(
		"users",
		"UserStatus",
		func() runtime.Object { return &User{} },
		func() runtime.Object { return &UserList{} },
	)
	InternalUserAccessKeysREST = builders.NewInternalSubresource(
		"users", "UserAccessKeys", "accesskeys",
		func() runtime.Object { return &UserAccessKeys{} },
	)
	NewUserAccessKeysREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserAccessKeysRESTFunc(Factory)
	}
	NewUserAccessKeysRESTFunc NewRESTFunc
	InternalUserClustersREST  = builders.NewInternalSubresource(
		"users", "UserClusters", "clusters",
		func() runtime.Object { return &UserClusters{} },
	)
	NewUserClustersREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserClustersRESTFunc(Factory)
	}
	NewUserClustersRESTFunc           NewRESTFunc
	InternalUserObjectPermissionsREST = builders.NewInternalSubresource(
		"users", "UserObjectPermissions", "object-permissions",
		func() runtime.Object { return &UserObjectPermissions{} },
	)
	NewUserObjectPermissionsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserObjectPermissionsRESTFunc(Factory)
	}
	NewUserObjectPermissionsRESTFunc NewRESTFunc
	InternalUserPermissionsREST      = builders.NewInternalSubresource(
		"users", "UserPermissions", "permissions",
		func() runtime.Object { return &UserPermissions{} },
	)
	NewUserPermissionsREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserPermissionsRESTFunc(Factory)
	}
	NewUserPermissionsRESTFunc NewRESTFunc
	InternalUserProfileREST    = builders.NewInternalSubresource(
		"users", "UserProfile", "profile",
		func() runtime.Object { return &UserProfile{} },
	)
	NewUserProfileREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewUserProfileRESTFunc(Factory)
	}
	NewUserProfileRESTFunc         NewRESTFunc
	InternalVirtualClusterInstance = builders.NewInternalResource(
		"virtualclusterinstances",
		"VirtualClusterInstance",
		func() runtime.Object { return &VirtualClusterInstance{} },
		func() runtime.Object { return &VirtualClusterInstanceList{} },
	)
	InternalVirtualClusterInstanceStatus = builders.NewInternalResourceStatus(
		"virtualclusterinstances",
		"VirtualClusterInstanceStatus",
		func() runtime.Object { return &VirtualClusterInstance{} },
		func() runtime.Object { return &VirtualClusterInstanceList{} },
	)
	InternalVirtualClusterAccessKeyREST = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterAccessKey", "accesskey",
		func() runtime.Object { return &VirtualClusterAccessKey{} },
	)
	NewVirtualClusterAccessKeyREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterAccessKeyRESTFunc(Factory)
	}
	NewVirtualClusterAccessKeyRESTFunc         NewRESTFunc
	InternalVirtualClusterExternalDatabaseREST = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterExternalDatabase", "externaldatabase",
		func() runtime.Object { return &VirtualClusterExternalDatabase{} },
	)
	NewVirtualClusterExternalDatabaseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterExternalDatabaseRESTFunc(Factory)
	}
	NewVirtualClusterExternalDatabaseRESTFunc    NewRESTFunc
	InternalVirtualClusterInstanceKubeConfigREST = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterInstanceKubeConfig", "kubeconfig",
		func() runtime.Object { return &VirtualClusterInstanceKubeConfig{} },
	)
	NewVirtualClusterInstanceKubeConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceKubeConfigRESTFunc(Factory)
	}
	NewVirtualClusterInstanceKubeConfigRESTFunc NewRESTFunc
	InternalVirtualClusterInstanceLogREST       = builders.NewInternalSubresource(
		"virtualclusterinstances", "VirtualClusterInstanceLog", "log",
		func() runtime.Object { return &VirtualClusterInstanceLog{} },
	)
	NewVirtualClusterInstanceLogREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterInstanceLogRESTFunc(Factory)
	}
	NewVirtualClusterInstanceLogRESTFunc NewRESTFunc
	InternalVirtualClusterSchema         = builders.NewInternalResource(
		"virtualclusterschemas",
		"VirtualClusterSchema",
		func() runtime.Object { return &VirtualClusterSchema{} },
		func() runtime.Object { return &VirtualClusterSchemaList{} },
	)
	InternalVirtualClusterSchemaStatus = builders.NewInternalResourceStatus(
		"virtualclusterschemas",
		"VirtualClusterSchemaStatus",
		func() runtime.Object { return &VirtualClusterSchema{} },
		func() runtime.Object { return &VirtualClusterSchemaList{} },
	)
	InternalVirtualClusterTemplate = builders.NewInternalResource(
		"virtualclustertemplates",
		"VirtualClusterTemplate",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	InternalVirtualClusterTemplateStatus = builders.NewInternalResourceStatus(
		"virtualclustertemplates",
		"VirtualClusterTemplateStatus",
		func() runtime.Object { return &VirtualClusterTemplate{} },
		func() runtime.Object { return &VirtualClusterTemplateList{} },
	)
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("management.loft.sh").WithKinds(
		InternalAgentAuditEvent,
		InternalAgentAuditEventStatus,
		InternalAnnouncement,
		InternalAnnouncementStatus,
		InternalApp,
		InternalAppStatus,
		InternalAppCredentialsREST,
		InternalBackup,
		InternalBackupStatus,
		InternalBackupApplyREST,
		InternalCluster,
		InternalClusterStatus,
		InternalClusterAccessKeyREST,
		InternalClusterAgentConfigREST,
		InternalClusterChartsREST,
		InternalClusterDomainREST,
		InternalClusterMemberAccessREST,
		InternalClusterMembersREST,
		InternalClusterResetREST,
		InternalClusterVirtualClusterDefaultsREST,
		InternalClusterAccess,
		InternalClusterAccessStatus,
		InternalClusterRoleTemplate,
		InternalClusterRoleTemplateStatus,
		InternalConfig,
		InternalConfigStatus,
		InternalConvertVirtualClusterConfig,
		InternalConvertVirtualClusterConfigStatus,
		InternalDevPodEnvironmentTemplate,
		InternalDevPodEnvironmentTemplateStatus,
		InternalDevPodWorkspaceInstance,
		InternalDevPodWorkspaceInstanceStatus,
		InternalDevPodWorkspaceInstanceCancelREST,
		InternalDevPodWorkspaceInstanceDownloadREST,
		InternalDevPodWorkspaceInstanceLogREST,
		InternalDevPodWorkspaceInstanceStopREST,
		InternalDevPodWorkspaceInstanceTasksREST,
		InternalDevPodWorkspaceInstanceTroubleshootREST,
		InternalDevPodWorkspaceInstanceUpREST,
		InternalDevPodWorkspacePreset,
		InternalDevPodWorkspacePresetStatus,
		InternalDevPodWorkspaceTemplate,
		InternalDevPodWorkspaceTemplateStatus,
		InternalDirectClusterEndpointToken,
		InternalDirectClusterEndpointTokenStatus,
		InternalEvent,
		InternalEventStatus,
		InternalFeature,
		InternalFeatureStatus,
		InternalIngressAuthToken,
		InternalIngressAuthTokenStatus,
		InternalKiosk,
		InternalKioskStatus,
		InternalLicense,
		InternalLicenseStatus,
		InternalLicenseRequestREST,
		InternalLicenseToken,
		InternalLicenseTokenStatus,
		InternalLoftUpgrade,
		InternalLoftUpgradeStatus,
		InternalOIDCClient,
		InternalOIDCClientStatus,
		InternalOwnedAccessKey,
		InternalOwnedAccessKeyStatus,
		InternalProject,
		InternalProjectStatus,
		InternalProjectChartInfoREST,
		InternalProjectChartsREST,
		InternalProjectClustersREST,
		InternalProjectImportSpaceREST,
		InternalProjectMembersREST,
		InternalProjectMigrateSpaceInstanceREST,
		InternalProjectMigrateVirtualClusterInstanceREST,
		InternalProjectTemplatesREST,
		InternalProjectSecret,
		InternalProjectSecretStatus,
		InternalRedirectToken,
		InternalRedirectTokenStatus,
		InternalRegisterVirtualCluster,
		InternalRegisterVirtualClusterStatus,
		InternalResetAccessKey,
		InternalResetAccessKeyStatus,
		InternalSelf,
		InternalSelfStatus,
		InternalSelfSubjectAccessReview,
		InternalSelfSubjectAccessReviewStatus,
		InternalSharedSecret,
		InternalSharedSecretStatus,
		InternalSpaceInstance,
		InternalSpaceInstanceStatus,
		InternalSpaceTemplate,
		InternalSpaceTemplateStatus,
		InternalSubjectAccessReview,
		InternalSubjectAccessReviewStatus,
		InternalTask,
		InternalTaskStatus,
		InternalTaskLogREST,
		InternalTeam,
		InternalTeamStatus,
		InternalTeamAccessKeysREST,
		InternalTeamClustersREST,
		InternalTeamObjectPermissionsREST,
		InternalTeamPermissionsREST,
		InternalTranslateVClusterResourceName,
		InternalTranslateVClusterResourceNameStatus,
		InternalUser,
		InternalUserStatus,
		InternalUserAccessKeysREST,
		InternalUserClustersREST,
		InternalUserObjectPermissionsREST,
		InternalUserPermissionsREST,
		InternalUserProfileREST,
		InternalVirtualClusterInstance,
		InternalVirtualClusterInstanceStatus,
		InternalVirtualClusterAccessKeyREST,
		InternalVirtualClusterExternalDatabaseREST,
		InternalVirtualClusterInstanceKubeConfigREST,
		InternalVirtualClusterInstanceLogREST,
		InternalVirtualClusterSchema,
		InternalVirtualClusterSchemaStatus,
		InternalVirtualClusterTemplate,
		InternalVirtualClusterTemplateStatus,
	)

	// Required by code generated by go2idl
	AddToScheme = (&runtime.SchemeBuilder{
		ApiVersion.SchemeBuilder.AddToScheme,
		RegisterDefaults,
	}).AddToScheme
	SchemeBuilder      = ApiVersion.SchemeBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

type AccessKeyType string
type Level string
type RequestTarget string
type Stage string

type AgentAnalyticsSpec struct {
	AnalyticsEndpoint string `json:"analyticsEndpoint,omitempty"`
}

type AgentAuditConfig struct {
	Enabled              bool        `json:"enabled,omitempty"`
	DisableAgentSyncBack bool        `json:"disableAgentSyncBack,omitempty"`
	Level                int         `json:"level,omitempty"`
	Policy               AuditPolicy `json:"policy,omitempty"`
	Path                 string      `json:"path,omitempty"`
	MaxAge               int         `json:"maxAge,omitempty"`
	MaxBackups           int         `json:"maxBackups,omitempty"`
	MaxSize              int         `json:"maxSize,omitempty"`
	Compress             bool        `json:"compress,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AgentAuditEvent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AgentAuditEventSpec   `json:"spec,omitempty"`
	Status            AgentAuditEventStatus `json:"status,omitempty"`
}

type AgentAuditEventSpec struct {
	Events []*auditv1.Event `json:"events,omitempty"`
}

type AgentAuditEventStatus struct {
}

type AgentCostControlConfig struct {
	Enabled                  *bool `json:"enabled,omitempty"`
	CostControlClusterConfig `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Announcement struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AnnouncementSpec   `json:"spec,omitempty"`
	Status            AnnouncementStatus `json:"status,omitempty"`
}

type AnnouncementSpec struct {
}

type AnnouncementStatus struct {
	Announcement pkglicenseapi.Announcement `json:"announcement,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type App struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AppSpec   `json:"spec,omitempty"`
	Status            AppStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AppCredentials struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	ProjectSecretRefs map[string]string `json:"projectSecretRefs,omitempty"`
}

type AppSpec struct {
	storagev1.AppSpec `json:",inline"`
}

type AppStatus struct {
	storagev1.AppStatus `json:",inline"`
}

type Apps struct {
	NoDefault      bool                            `json:"noDefault,omitempty"`
	Repositories   []storagev1.HelmChartRepository `json:"repositories,omitempty"`
	PredefinedApps []PredefinedApp                 `json:"predefinedApps,omitempty"`
}

type AssignedVia struct {
	ObjectName `json:",inline"`
	Kind       string `json:"kind,omitempty"`
	Owner      bool   `json:"owner,omitempty"`
}

type Audit struct {
	Enabled              bool        `json:"enabled,omitempty"`
	DisableAgentSyncBack bool        `json:"disableAgentSyncBack,omitempty"`
	Level                int         `json:"level,omitempty"`
	Policy               AuditPolicy `json:"policy,omitempty"`
	DataStoreEndpoint    string      `json:"dataStoreEndpoint,omitempty"`
	DataStoreMaxAge      *int        `json:"dataStoreTTL,omitempty"`
	Path                 string      `json:"path,omitempty"`
	MaxAge               int         `json:"maxAge,omitempty"`
	MaxBackups           int         `json:"maxBackups,omitempty"`
	MaxSize              int         `json:"maxSize,omitempty"`
	Compress             bool        `json:"compress,omitempty"`
}

type AuditPolicy struct {
	Rules      []AuditPolicyRule `json:"rules,omitempty"`
	OmitStages []auditv1.Stage   `json:"omitStages,omitempty"`
}

type AuditPolicyRule struct {
	Level           auditv1.Level           `json:"level"`
	Users           []string                `json:"users,omitempty"`
	UserGroups      []string                `json:"userGroups,omitempty"`
	Verbs           []string                `json:"verbs,omitempty"`
	Resources       []GroupResources        `json:"resources,omitempty"`
	Namespaces      []string                `json:"namespaces,omitempty"`
	NonResourceURLs []string                `json:"nonResourceURLs,omitempty"`
	OmitStages      []auditv1.Stage         `json:"omitStages,omitempty" protobuf:"bytes,8,rep,name=omitStages"`
	RequestTargets  []auditv1.RequestTarget `json:"requestTargets,omitempty"`
	Clusters        []string                `json:"clusters,omitempty"`
}

type Authentication struct {
	Connector                `json:",inline"`
	Rancher                  *AuthenticationRancher  `json:"rancher,omitempty"`
	Password                 *AuthenticationPassword `json:"password,omitempty"`
	Connectors               []ConnectorWithName     `json:"connectors,omitempty"`
	DisableTeamCreation      bool                    `json:"disableTeamCreation,omitempty"`
	DisableUserCreation      bool                    `json:"disableUserCreation,omitempty"`
	AccessKeyMaxTTLSeconds   int64                   `json:"accessKeyMaxTTLSeconds,omitempty"`
	LoginAccessKeyTTLSeconds *int64                  `json:"loginAccessKeyTTLSeconds,omitempty"`
	CustomHttpHeaders        map[string]string       `json:"customHttpHeaders,omitempty"`
	GroupsFilters            []string                `json:"groupsFilters,omitempty"`
}

type AuthenticationGithub struct {
	ClientID     string                    `json:"clientId,omitempty"`
	ClientSecret string                    `json:"clientSecret"`
	RedirectURI  string                    `json:"redirectURI"`
	Orgs         []AuthenticationGithubOrg `json:"orgs,omitempty"`
	HostName     string                    `json:"hostName,omitempty"`
	RootCA       string                    `json:"rootCA,omitempty"`
}

type AuthenticationGithubOrg struct {
	Name  string   `json:"name"`
	Teams []string `json:"teams,omitempty"`
}

type AuthenticationGitlab struct {
	ClientID     string   `json:"clientId"`
	ClientSecret string   `json:"clientSecret"`
	RedirectURI  string   `json:"redirectURI"`
	BaseURL      string   `json:"baseURL,omitempty"`
	Groups       []string `json:"groups,omitempty"`
}

type AuthenticationGoogle struct {
	ClientID               string   `json:"clientId"`
	ClientSecret           string   `json:"clientSecret"`
	RedirectURI            string   `json:"redirectURI"`
	Scopes                 []string `json:"scopes,omitempty"`
	HostedDomains          []string `json:"hostedDomains,omitempty"`
	Groups                 []string `json:"groups,omitempty"`
	ServiceAccountFilePath string   `json:"serviceAccountFilePath,omitempty"`
	AdminEmail             string   `json:"adminEmail,omitempty"`
}

type AuthenticationMicrosoft struct {
	ClientID             string   `json:"clientId"`
	ClientSecret         string   `json:"clientSecret"`
	RedirectURI          string   `json:"redirectURI"`
	Tenant               string   `json:"tenant,omitempty"`
	Groups               []string `json:"groups,omitempty"`
	OnlySecurityGroups   bool     `json:"onlySecurityGroups,omitempty"`
	UseGroupsAsWhitelist bool     `json:"useGroupsAsWhitelist,omitempty"`
}

type AuthenticationOIDC struct {
	IssuerURL              string   `json:"issuerUrl,omitempty"`
	ClientID               string   `json:"clientId,omitempty"`
	ClientSecret           string   `json:"clientSecret,omitempty"`
	RedirectURI            string   `json:"redirectURI,omitempty"`
	PostLogoutRedirectURI  string   `json:"postLogoutRedirectURI,omitempty"`
	CAFile                 string   `json:"caFile,omitempty"`
	InsecureCA             bool     `json:"insecureCa,omitempty"`
	PreferredUsernameClaim string   `json:"preferredUsername,omitempty"`
	LoftUsernameClaim      string   `json:"loftUsernameClaim,omitempty"`
	UsernameClaim          string   `json:"usernameClaim,omitempty"`
	EmailClaim             string   `json:"emailClaim,omitempty"`
	UsernamePrefix         string   `json:"usernamePrefix,omitempty"`
	GroupsClaim            string   `json:"groupsClaim,omitempty"`
	Groups                 []string `json:"groups,omitempty"`
	Scopes                 []string `json:"scopes,omitempty"`
	GetUserInfo            bool     `json:"getUserInfo,omitempty"`
	GroupsPrefix           string   `json:"groupsPrefix,omitempty"`
	Type                   string   `json:"type,omitempty"`
}

type AuthenticationPassword struct {
	Disabled bool `json:"disabled,omitempty"`
}

type AuthenticationRancher struct {
	Host        string `json:"host,omitempty"`
	BearerToken string `json:"bearerToken,omitempty"`
	Insecure    bool   `json:"insecure,omitempty"`
}

type AuthenticationSAML struct {
	RedirectURI                     string   `json:"redirectURI,omitempty"`
	SSOURL                          string   `json:"ssoURL,omitempty"`
	CAData                          []byte   `json:"caData,omitempty"`
	UsernameAttr                    string   `json:"usernameAttr,omitempty"`
	EmailAttr                       string   `json:"emailAttr,omitempty"`
	GroupsAttr                      string   `json:"groupsAttr,omitempty"`
	CA                              string   `json:"ca,omitempty"`
	InsecureSkipSignatureValidation bool     `json:"insecureSkipSignatureValidation,omitempty"`
	EntityIssuer                    string   `json:"entityIssuer,omitempty"`
	SSOIssuer                       string   `json:"ssoIssuer,omitempty"`
	GroupsDelim                     string   `json:"groupsDelim,omitempty"`
	AllowedGroups                   []string `json:"allowedGroups,omitempty"`
	FilterGroups                    bool     `json:"filterGroups,omitempty"`
	NameIDPolicyFormat              string   `json:"nameIDPolicyFormat,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Backup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupSpec   `json:"spec,omitempty"`
	Status            BackupStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type BackupApply struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupApplySpec `json:"spec,omitempty"`
}

type BackupApplySpec struct {
	Raw string `json:"raw,omitempty"`
}

type BackupSpec struct {
}

type BackupStatus struct {
	RawBackup string `json:"rawBackup,omitempty"`
}

type Cloud struct {
	ReleaseChannel    string            `json:"releaseChannel,omitempty"`
	MaintenanceWindow MaintenanceWindow `json:"maintenanceWindow,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec,omitempty"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccess struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterAccessSpec   `json:"spec,omitempty"`
	Status            ClusterAccessStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccessKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	AccessKey         string `json:"accessKey,omitempty"`
	LoftHost          string `json:"loftHost,omitempty"`
	Insecure          bool   `json:"insecure,omitempty"`
	CaCert            string `json:"caCert,omitempty"`
}

type ClusterAccessRole struct {
	ObjectName  `json:",inline"`
	Clusters    []ObjectName `json:"clusters,omitempty"`
	AssignedVia AssignedVia  `json:"assignedVia,omitempty"`
}

type ClusterAccessSpec struct {
	storagev1.ClusterAccessSpec `json:",inline"`
}

type ClusterAccessStatus struct {
	storagev1.ClusterAccessStatus `json:",inline"`
	Clusters                      []*storagev1.EntityInfo       `json:"clusters,omitempty"`
	Users                         []*storagev1.UserOrTeamEntity `json:"users,omitempty"`
	Teams                         []*storagev1.EntityInfo       `json:"teams,omitempty"`
}

type ClusterAccounts struct {
	Accounts []string          `json:"accounts,omitempty"`
	Cluster  storagev1.Cluster `json:"cluster,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAgentConfig struct {
	metav1.TypeMeta          `json:",inline"`
	metav1.ObjectMeta        `json:"metadata,omitempty"`
	ClusterAgentConfigCommon `json:",inline"`
}

type ClusterAgentConfigCommon struct {
	Cluster                string                  `json:"cluster,omitempty"`
	Audit                  *AgentAuditConfig       `json:"audit,omitempty"`
	DefaultImageRegistry   string                  `json:"defaultImageRegistry,omitempty"`
	TokenCaCert            []byte                  `json:"tokenCaCert,omitempty"`
	LoftHost               string                  `json:"loftHost,omitempty"`
	ProjectNamespacePrefix string                  `json:"projectNamespacePrefix,omitempty"`
	LoftInstanceID         string                  `json:"loftInstanceID,omitempty"`
	AnalyticsSpec          AgentAnalyticsSpec      `json:"analyticsSpec"`
	CostControl            *AgentCostControlConfig `json:"costControl,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterCharts struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Charts            []storagev1.HelmChart `json:"charts"`
	Busy              bool                  `json:"busy,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomain struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Target            string `json:"target,omitempty"`
	Domain            string `json:"domain,omitempty"`
}

type ClusterMember struct {
	Info storagev1.EntityInfo `json:"info,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMemberAccess struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Teams             []ClusterMember `json:"teams,omitempty"`
	Users             []ClusterMember `json:"users,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembers struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Teams             []ClusterMember `json:"teams,omitempty"`
	Users             []ClusterMember `json:"users,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterReset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Agent             bool `json:"agent,omitempty"`
	RBAC              bool `json:"rbac,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRoleTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterRoleTemplateSpec   `json:"spec,omitempty"`
	Status            ClusterRoleTemplateStatus `json:"status,omitempty"`
}

type ClusterRoleTemplateSpec struct {
	storagev1.ClusterRoleTemplateSpec `json:",inline"`
}

type ClusterRoleTemplateStatus struct {
	storagev1.ClusterRoleTemplateStatus `json:",inline"`
	Clusters                            []*storagev1.EntityInfo `json:"clusters,omitempty"`
}

type ClusterSpec struct {
	storagev1.ClusterSpec `json:",inline"`
}

type ClusterStatus struct {
	storagev1.ClusterStatus `json:",inline"`
	Online                  bool `json:"online,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaults struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	DefaultTemplate   *storagev1.VirtualClusterTemplate `json:"defaultTemplate,omitempty"`
	LatestVersion     string                            `json:"latestVersion,omitempty"`
	Values            string                            `json:"values,omitempty"`
	Warning           string                            `json:"warning,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Config struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConfigSpec   `json:"spec,omitempty"`
	Status            ConfigStatus `json:"status,omitempty"`
}

type ConfigSpec struct {
	Raw []byte `json:"raw,omitempty"`
}

type ConfigStatus struct {
	Authentication         Authentication                  `json:"auth,omitempty"`
	OIDC                   *OIDC                           `json:"oidc,omitempty"`
	Apps                   *Apps                           `json:"apps,omitempty"`
	Audit                  *Audit                          `json:"audit,omitempty"`
	LoftHost               string                          `json:"loftHost,omitempty"`
	ProjectNamespacePrefix *string                         `json:"projectNamespacePrefix,omitempty"`
	DevPodSubDomain        string                          `json:"devPodSubDomain,omitempty"`
	UISettings             *uiv1.UISettingsConfig          `json:"uiSettings,omitempty"`
	VaultIntegration       *storagev1.VaultIntegrationSpec `json:"vault,omitempty"`
	DisableConfigEndpoint  bool                            `json:"disableConfigEndpoint,omitempty"`
	Cloud                  *Cloud                          `json:"cloud,omitempty"`
	CostControl            *CostControl                    `json:"costControl,omitempty"`
	ImageBuilder           *ImageBuilder                   `json:"imageBuilder,omitempty"`
}

type Connector struct {
	OIDC      *AuthenticationOIDC      `json:"oidc,omitempty"`
	Github    *AuthenticationGithub    `json:"github,omitempty"`
	Gitlab    *AuthenticationGitlab    `json:"gitlab,omitempty"`
	Google    *AuthenticationGoogle    `json:"google,omitempty"`
	Microsoft *AuthenticationMicrosoft `json:"microsoft,omitempty"`
	SAML      *AuthenticationSAML      `json:"saml,omitempty"`
}

type ConnectorWithName struct {
	ID          string `json:"id,omitempty"`
	DisplayName string `json:"displayName,omitempty"`
	Connector   `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConvertVirtualClusterConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConvertVirtualClusterConfigSpec   `json:"spec,omitempty"`
	Status            ConvertVirtualClusterConfigStatus `json:"status,omitempty"`
}

type ConvertVirtualClusterConfigSpec struct {
	Annotations map[string]string `json:"annotations,omitempty"`
	Distro      string            `json:"distro,omitempty"`
	Values      string            `json:"values,omitempty"`
}

type ConvertVirtualClusterConfigStatus struct {
	Values    string `json:"values,omitempty"`
	Converted bool   `json:"converted"`
}

type CostControl struct {
	Enabled  *bool                    `json:"enabled,omitempty"`
	Global   CostControlGlobalConfig  `json:"global,omitempty"`
	Cluster  CostControlClusterConfig `json:"cluster,omitempty"`
	Settings *CostControlSettings     `json:"settings,omitempty"`
}

type CostControlClusterConfig struct {
	Metrics  *storagev1.Metrics  `json:"metrics,omitempty"`
	OpenCost *storagev1.OpenCost `json:"opencost,omitempty"`
}

type CostControlGPUSettings struct {
	Enabled     bool                      `json:"enabled,omitempty"`
	AvgGPUPrice *CostControlResourcePrice `json:"averageGPUPrice,omitempty"`
}

type CostControlGlobalConfig struct {
	Metrics *storagev1.Metrics `json:"metrics,omitempty"`
}

type CostControlResourcePrice struct {
	Price      float64 `json:"price,omitempty"`
	TimePeriod string  `json:"timePeriod,omitempty"`
}

type CostControlSettings struct {
	PriceCurrency               string                    `json:"priceCurrency,omitempty"`
	AvgCPUPricePerNode          *CostControlResourcePrice `json:"averageCPUPricePerNode,omitempty"`
	AvgRAMPricePerNode          *CostControlResourcePrice `json:"averageRAMPricePerNode,omitempty"`
	GPUSettings                 *CostControlGPUSettings   `json:"gpuSettings,omitempty"`
	ControlPlanePricePerCluster *CostControlResourcePrice `json:"controlPlanePricePerCluster,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodEnvironmentTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodEnvironmentTemplateSpec   `json:"spec,omitempty"`
	Status            DevPodEnvironmentTemplateStatus `json:"status,omitempty"`
}

type DevPodEnvironmentTemplateSpec struct {
	storagev1.DevPodEnvironmentTemplateSpec `json:",inline"`
}

type DevPodEnvironmentTemplateStatus struct {
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodWorkspaceInstanceSpec   `json:"spec,omitempty"`
	Status            DevPodWorkspaceInstanceStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceCancel struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	TaskID            string `json:"taskId,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceDownload struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceLog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
}

type DevPodWorkspaceInstanceSpec struct {
	storagev1.DevPodWorkspaceInstanceSpec `json:",inline"`
}

type DevPodWorkspaceInstanceStatus struct {
	storagev1.DevPodWorkspaceInstanceStatus `json:",inline"`
	SleepModeConfig                         *clusterv1.SleepModeConfig `json:"sleepModeConfig,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceStop struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodWorkspaceInstanceStopSpec   `json:"spec,omitempty"`
	Status            DevPodWorkspaceInstanceStopStatus `json:"status,omitempty"`
}

type DevPodWorkspaceInstanceStopSpec struct {
	Options string `json:"options,omitempty"`
}

type DevPodWorkspaceInstanceStopStatus struct {
	TaskID string `json:"taskId,omitempty"`
}

type DevPodWorkspaceInstanceTask struct {
	ID        string      `json:"id,omitempty"`
	Type      string      `json:"type,omitempty"`
	Status    string      `json:"status,omitempty"`
	Result    []byte      `json:"result,omitempty"`
	Logs      []byte      `json:"logs,omitempty"`
	CreatedAt metav1.Time `json:"createdAt,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceTasks struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Tasks             []DevPodWorkspaceInstanceTask `json:"tasks,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceTroubleshoot struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	State             string                             `json:"state,omitempty"`
	Workspace         *DevPodWorkspaceInstance           `json:"workspace,omitempty"`
	Template          *storagev1.DevPodWorkspaceTemplate `json:"template,omitempty"`
	Pods              []corev1.Pod                       `json:"pods,omitempty"`
	PVCs              []corev1.PersistentVolumeClaim     `json:"pvcs,omitempty"`
	Netmaps           []string                           `json:"netmaps,omitempty"`
	Errors            []string                           `json:"errors,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceUp struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodWorkspaceInstanceUpSpec   `json:"spec,omitempty"`
	Status            DevPodWorkspaceInstanceUpStatus `json:"status,omitempty"`
}

type DevPodWorkspaceInstanceUpSpec struct {
	Debug   bool   `json:"debug,omitempty"`
	Options string `json:"options,omitempty"`
}

type DevPodWorkspaceInstanceUpStatus struct {
	TaskID string `json:"taskId,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspacePreset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodWorkspacePresetSpec   `json:"spec,omitempty"`
	Status            DevPodWorkspacePresetStatus `json:"status,omitempty"`
}

type DevPodWorkspacePresetSpec struct {
	storagev1.DevPodWorkspacePresetSpec `json:",inline"`
}

type DevPodWorkspacePresetStatus struct {
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DevPodWorkspaceTemplateSpec   `json:"spec,omitempty"`
	Status            DevPodWorkspaceTemplateStatus `json:"status,omitempty"`
}

type DevPodWorkspaceTemplateSpec struct {
	storagev1.DevPodWorkspaceTemplateSpec `json:",inline"`
}

type DevPodWorkspaceTemplateStatus struct {
	storagev1.DevPodWorkspaceTemplateStatus `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointToken struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DirectClusterEndpointTokenSpec   `json:"spec,omitempty"`
	Status            DirectClusterEndpointTokenStatus `json:"status,omitempty"`
}

type DirectClusterEndpointTokenSpec struct {
	TTL   int64                     `json:"ttl,omitempty"`
	Scope *storagev1.AccessKeyScope `json:"scope,omitempty"`
}

type DirectClusterEndpointTokenStatus struct {
	Token string `json:"token,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Event struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EventSpec   `json:"spec,omitempty"`
	Status            EventStatus `json:"status,omitempty"`
}

type EventSpec struct {
}

type EventStatus struct {
	auditv1.Event `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Feature struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FeatureSpec   `json:"spec,omitempty"`
	Status            FeatureStatus `json:"status,omitempty"`
}

type FeatureSpec struct {
}

type FeatureStatus struct {
	pkglicenseapi.Feature `json:",inline"`
	Internal              bool `json:"internal,omitempty"`
	Used                  bool `json:"used,omitempty"`
}

type GroupResources struct {
	Group         string   `json:"group,omitempty" protobuf:"bytes,1,opt,name=group"`
	Resources     []string `json:"resources,omitempty" protobuf:"bytes,2,rep,name=resources"`
	ResourceNames []string `json:"resourceNames,omitempty" protobuf:"bytes,3,rep,name=resourceNames"`
}

type ImageBuilder struct {
	Enabled   *bool                        `json:"enabled,omitempty"`
	Replicas  *int32                       `json:"replicas,omitempty"`
	Resources *corev1.ResourceRequirements `json:"resources,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type IngressAuthToken struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IngressAuthTokenSpec   `json:"spec,omitempty"`
	Status            IngressAuthTokenStatus `json:"status,omitempty"`
}

type IngressAuthTokenSpec struct {
	Host      string `json:"host,omitempty"`
	Signature string `json:"signature,omitempty"`
}

type IngressAuthTokenStatus struct {
	Token string `json:"token,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Kiosk struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KioskSpec   `json:"spec,omitempty"`
	Status            KioskStatus `json:"status,omitempty"`
}

type KioskSpec struct {
	HelmRelease         clusterv1.HelmRelease       `json:"helmRelease,omitempty"`
	SleepModeConfig     clusterv1.SleepModeConfig   `json:"sleepModeConfig,omitempty"`
	ChartInfo           clusterv1.ChartInfo         `json:"chartInfo,omitempty"`
	StorageClusterQuota agentstoragev1.ClusterQuota `json:"storageClusterQuota,omitempty"`
	UISettings          uiv1.UISettings             `json:"UISettings,omitempty"`
	License             License                     `json:"license,omitempty"`
}

type KioskStatus struct {
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type License struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LicenseSpec   `json:"spec,omitempty"`
	Status            LicenseStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseRequest struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LicenseRequestSpec   `json:"spec,omitempty"`
	Status            LicenseRequestStatus `json:"status,omitempty"`
}

type LicenseRequestSpec struct {
	URL   string                            `json:"url,omitempty"`
	Input pkglicenseapi.GenericRequestInput `json:"input,omitempty"`
}

type LicenseRequestStatus struct {
	Output *pkglicenseapi.GenericRequestOutput `json:"output,omitempty"`
}

type LicenseSpec struct {
}

type LicenseStatus struct {
	License       *pkglicenseapi.License                 `json:"license,omitempty"`
	ResourceUsage map[string]pkglicenseapi.ResourceCount `json:"resourceUsage,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseToken struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LicenseTokenSpec   `json:"spec,omitempty"`
	Status            LicenseTokenStatus `json:"status,omitempty"`
}

type LicenseTokenSpec struct {
	URL     string `json:"url,omitempty"`
	Payload string `json:"payload,omitempty"`
}

type LicenseTokenStatus struct {
	Token *pkglicenseapi.InstanceTokenAuth `json:"token,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgrade struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoftUpgradeSpec   `json:"spec,omitempty"`
	Status            LoftUpgradeStatus `json:"status,omitempty"`
}

type LoftUpgradeSpec struct {
	Namespace string `json:"namespace,omitempty"`
	Release   string `json:"release,omitempty"`
	Version   string `json:"version,omitempty"`
}

type LoftUpgradeStatus struct {
}

type MaintenanceWindow struct {
	DayOfWeek  string `json:"dayOfWeek,omitempty"`
	TimeWindow string `json:"timeWindow,omitempty"`
}

type ManagementRole struct {
	ObjectName  `json:",inline"`
	AssignedVia AssignedVia `json:"assignedVia,omitempty"`
}

type OIDC struct {
	Enabled          bool             `json:"enabled,omitempty"`
	WildcardRedirect bool             `json:"wildcardRedirect,omitempty"`
	Clients          []OIDCClientSpec `json:"clients,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OIDCClient struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              OIDCClientSpec   `json:"spec,omitempty"`
	Status            OIDCClientStatus `json:"status,omitempty"`
}

type OIDCClientSpec struct {
	Name         string   `json:"name,omitempty"`
	ClientID     string   `json:"clientId,omitempty"`
	ClientSecret string   `json:"clientSecret,omitempty"`
	RedirectURIs []string `json:"redirectURIs"`
}

type OIDCClientStatus struct {
}

type ObjectName struct {
	Namespace   string `json:"namespace,omitempty"`
	Name        string `json:"name,omitempty"`
	DisplayName string `json:"displayName,omitempty"`
}

type ObjectPermission struct {
	ObjectName `json:",inline"`
	Verbs      []string `json:"verbs" protobuf:"bytes,1,rep,name=verbs"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              OwnedAccessKeySpec   `json:"spec,omitempty"`
	Status            OwnedAccessKeyStatus `json:"status,omitempty"`
}

type OwnedAccessKeySpec struct {
	storagev1.AccessKeySpec `json:",inline"`
}

type OwnedAccessKeyStatus struct {
	storagev1.AccessKeyStatus `json:",inline"`
}

type PredefinedApp struct {
	Chart          string   `json:"chart"`
	InitialVersion string   `json:"initialVersion,omitempty"`
	InitialValues  string   `json:"initialValues,omitempty"`
	Clusters       []string `json:"clusters,omitempty"`
	Title          string   `json:"title,omitempty"`
	IconURL        string   `json:"iconUrl,omitempty"`
	ReadmeURL      string   `json:"readmeUrl,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Project struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProjectSpec   `json:"spec,omitempty"`
	Status            ProjectStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartInfo struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProjectChartInfoSpec   `json:"spec,omitempty"`
	Status            ProjectChartInfoStatus `json:"status,omitempty"`
}

type ProjectChartInfoSpec struct {
	clusterv1.ChartInfoSpec `json:",inline"`
}

type ProjectChartInfoStatus struct {
	clusterv1.ChartInfoStatus `json:",inline"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectCharts struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Charts            []storagev1.HelmChart `json:"charts"`
	Busy              bool                  `json:"busy,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectClusters struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Clusters          []Cluster `json:"clusters,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportSpace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	SourceSpace       ProjectImportSpaceSource `json:"sourceSpace"`
}

type ProjectImportSpaceSource struct {
	Name       string `json:"name,omitempty"`
	Cluster    string `json:"cluster,omitempty"`
	ImportName string `json:"importName,omitempty"`
}

type ProjectMember struct {
	Info storagev1.EntityInfo `json:"info,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMembers struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Teams             []ProjectMember `json:"teams,omitempty"`
	Users             []ProjectMember `json:"users,omitempty"`
}

type ProjectMembership struct {
	ObjectName  `json:",inline"`
	Role        ProjectRole `json:"role,omitempty"`
	AssignedVia AssignedVia `json:"assignedVia,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateSpaceInstance struct {
	metav1.TypeMeta     `json:",inline"`
	metav1.ObjectMeta   `json:"metadata,omitempty"`
	SourceSpaceInstance ProjectMigrateSpaceInstanceSource `json:"sourceSpaceInstance"`
}

type ProjectMigrateSpaceInstanceSource struct {
	Name      string `json:"name,omitempty"`
	Namespace string `json:"namespace,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateVirtualClusterInstance struct {
	metav1.TypeMeta              `json:",inline"`
	metav1.ObjectMeta            `json:"metadata,omitempty"`
	SourceVirtualClusterInstance ProjectMigrateVirtualClusterInstanceSource `json:"sourceVirtualClusterInstance"`
}

type ProjectMigrateVirtualClusterInstanceSource struct {
	Name      string `json:"name,omitempty"`
	Namespace string `json:"namespace,omitempty"`
}

type ProjectRole struct {
	ObjectName `json:",inline"`
	IsAdmin    bool `json:"isAdmin,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectSecret struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProjectSecretSpec   `json:"spec,omitempty"`
	Status            ProjectSecretStatus `json:"status,omitempty"`
}

type ProjectSecretSpec struct {
	DisplayName string                `json:"displayName,omitempty"`
	Description string                `json:"description,omitempty"`
	Owner       *storagev1.UserOrTeam `json:"owner,omitempty"`
	Data        map[string][]byte     `json:"data,omitempty"`
	Access      []storagev1.Access    `json:"access,omitempty"`
}

type ProjectSecretStatus struct {
	Conditions agentstoragev1.Conditions `json:"conditions,omitempty"`
}

type ProjectSpec struct {
	storagev1.ProjectSpec `json:",inline"`
}

type ProjectStatus struct {
	storagev1.ProjectStatus `json:",inline"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectTemplates struct {
	metav1.TypeMeta                  `json:",inline"`
	metav1.ObjectMeta                `json:"metadata,omitempty"`
	DefaultVirtualClusterTemplate    string                      `json:"defaultVirtualClusterTemplate,omitempty"`
	VirtualClusterTemplates          []VirtualClusterTemplate    `json:"virtualClusterTemplates,omitempty"`
	DefaultSpaceTemplate             string                      `json:"defaultSpaceTemplate,omitempty"`
	SpaceTemplates                   []SpaceTemplate             `json:"spaceTemplates,omitempty"`
	DefaultDevPodWorkspaceTemplate   string                      `json:"defaultDevPodWorkspaceTemplate,omitempty"`
	DevPodWorkspaceTemplates         []DevPodWorkspaceTemplate   `json:"devPodWorkspaceTemplates,omitempty"`
	DevPodEnvironmentTemplates       []DevPodEnvironmentTemplate `json:"devPodEnvironmentTemplates,omitempty"`
	DevPodWorkspacePresets           []DevPodWorkspacePreset     `json:"devPodWorkspacePresets,omitempty"`
	DefaultDevPodEnvironmentTemplate string                      `json:"defaultDevPodEnvironmentTemplate,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RedirectToken struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RedirectTokenSpec   `json:"spec,omitempty"`
	Status            RedirectTokenStatus `json:"status,omitempty"`
}

type RedirectTokenSpec struct {
	Token string `json:"token,omitempty"`
}

type RedirectTokenStatus struct {
	RedirectURL string `json:"redirectURL,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RegisterVirtualCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RegisterVirtualClusterSpec   `json:"spec,omitempty"`
	Status            RegisterVirtualClusterStatus `json:"status,omitempty"`
}

type RegisterVirtualClusterSpec struct {
	ServiceUID string `json:"serviceUID,omitempty"`
	Project    string `json:"project,omitempty"`
	Name       string `json:"name,omitempty"`
	ForceName  bool   `json:"forceName,omitempty"`
	Chart      string `json:"chart,omitempty"`
	Version    string `json:"version,omitempty"`
	Values     string `json:"values,omitempty"`
}

type RegisterVirtualClusterStatus struct {
	Name string `json:"name,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ResetAccessKeySpec   `json:"spec,omitempty"`
	Status            ResetAccessKeyStatus `json:"status,omitempty"`
}

type ResetAccessKeySpec struct {
	storagev1.AccessKeySpec `json:",inline"`
}

type ResetAccessKeyStatus struct {
	storagev1.AccessKeyStatus `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Self struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SelfSpec   `json:"spec,omitempty"`
	Status            SelfStatus `json:"status,omitempty"`
}

type SelfSpec struct {
	AccessKey string `json:"accessKey,omitempty"`
}

type SelfStatus struct {
	User                   *UserInfo                 `json:"user,omitempty"`
	Team                   *storagev1.EntityInfo     `json:"team,omitempty"`
	AccessKey              string                    `json:"accessKey,omitempty"`
	AccessKeyScope         *storagev1.AccessKeyScope `json:"accessKeyScope,omitempty"`
	AccessKeyType          storagev1.AccessKeyType   `json:"accessKeyType,omitempty"`
	Subject                string                    `json:"subject,omitempty"`
	UID                    string                    `json:"uid,omitempty"`
	Groups                 []string                  `json:"groups,omitempty"`
	ChatAuthToken          string                    `json:"chatAuthToken,omitempty"`
	InstanceID             string                    `json:"instanceID,omitempty"`
	ProjectNamespacePrefix *string                   `json:"projectNamespacePrefix,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReview struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SelfSubjectAccessReviewSpec   `json:"spec,omitempty"`
	Status            SelfSubjectAccessReviewStatus `json:"status,omitempty"`
}

type SelfSubjectAccessReviewSpec struct {
	authorizationv1.SelfSubjectAccessReviewSpec `json:",inline"`
}

type SelfSubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus `json:",inline"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecret struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SharedSecretSpec   `json:"spec,omitempty"`
	Status            SharedSecretStatus `json:"status,omitempty"`
}

type SharedSecretSpec struct {
	storagev1.SharedSecretSpec `json:",inline"`
}

type SharedSecretStatus struct {
	storagev1.SharedSecretStatus `json:",inline"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SpaceInstanceSpec   `json:"spec,omitempty"`
	Status            SpaceInstanceStatus `json:"status,omitempty"`
}

type SpaceInstanceSpec struct {
	storagev1.SpaceInstanceSpec `json:",inline"`
}

type SpaceInstanceStatus struct {
	storagev1.SpaceInstanceStatus `json:",inline"`
	SleepModeConfig               *clusterv1.SleepModeConfig `json:"sleepModeConfig,omitempty"`
	CanUse                        bool                       `json:"canUse,omitempty"`
	CanUpdate                     bool                       `json:"canUpdate,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SpaceTemplateSpec   `json:"spec,omitempty"`
	Status            SpaceTemplateStatus `json:"status,omitempty"`
}

type SpaceTemplateSpec struct {
	storagev1.SpaceTemplateSpec `json:",inline"`
}

type SpaceTemplateStatus struct {
	storagev1.SpaceTemplateStatus `json:",inline"`
	Apps                          []*storagev1.EntityInfo `json:"apps,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReview struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SubjectAccessReviewSpec   `json:"spec,omitempty"`
	Status            SubjectAccessReviewStatus `json:"status,omitempty"`
}

type SubjectAccessReviewSpec struct {
	authorizationv1.SubjectAccessReviewSpec `json:",inline"`
}

type SubjectAccessReviewStatus struct {
	authorizationv1.SubjectAccessReviewStatus `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Task struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TaskSpec   `json:"spec,omitempty"`
	Status            TaskStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
}

type TaskSpec struct {
	storagev1.TaskSpec `json:",inline"`
}

type TaskStatus struct {
	storagev1.TaskStatus `json:",inline"`
	Owner                *storagev1.UserOrTeamEntity `json:"owner,omitempty"`
	Cluster              *storagev1.EntityInfo       `json:"cluster,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Team struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TeamSpec   `json:"spec,omitempty"`
	Status            TeamStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeys struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	AccessKeys        []OwnedAccessKey `json:"accessKeys,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClusters struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Clusters          []ClusterAccounts `json:"clusters,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamObjectPermissions struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	ObjectPermissions []ObjectPermission `json:"objectPermissions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamPermissions struct {
	metav1.TypeMeta     `json:",inline"`
	metav1.ObjectMeta   `json:"metadata,omitempty"`
	Members             []ObjectName         `json:"members,omitempty"`
	ProjectMemberships  []ProjectMembership  `json:"projectMemberships,omitempty"`
	ManagementRoles     []ManagementRole     `json:"managementRoles,omitempty"`
	ClusterAccessRoles  []ClusterAccessRole  `json:"clusterAccessRoles,omitempty"`
	VirtualClusterRoles []VirtualClusterRole `json:"virtualClusterRoles,omitempty"`
}

type TeamSpec struct {
	storagev1.TeamSpec `json:",inline"`
}

type TeamStatus struct {
	storagev1.TeamStatus `json:",inline"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TranslateVClusterResourceName struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TranslateVClusterResourceNameSpec   `json:"spec,omitempty"`
	Status            TranslateVClusterResourceNameStatus `json:"status,omitempty"`
}

type TranslateVClusterResourceNameSpec struct {
	Name         string `json:"name"`
	Namespace    string `json:"namespace"`
	VClusterName string `json:"vclusterName"`
}

type TranslateVClusterResourceNameStatus struct {
	Name string `json:"name,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type User struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              UserSpec   `json:"spec,omitempty"`
	Status            UserStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeys struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	AccessKeys        []OwnedAccessKey `json:"accessKeys,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClusters struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Clusters          []ClusterAccounts `json:"clusters,omitempty"`
}

type UserInfo struct {
	storagev1.EntityInfo `json:",inline"`
	Teams                []*storagev1.EntityInfo `json:"teams,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserObjectPermissions struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	ObjectPermissions []ObjectPermission `json:"objectPermissions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserPermissions struct {
	metav1.TypeMeta     `json:",inline"`
	metav1.ObjectMeta   `json:"metadata,omitempty"`
	ClusterRoles        []UserPermissionsRole `json:"clusterRoles,omitempty"`
	NamespaceRoles      []UserPermissionsRole `json:"namespaceRoles,omitempty"`
	TeamMemberships     []ObjectName          `json:"teamMemberships,omitempty"`
	ProjectMemberships  []ProjectMembership   `json:"projectMemberships,omitempty"`
	ManagementRoles     []ManagementRole      `json:"managementRoles,omitempty"`
	ClusterAccessRoles  []ClusterAccessRole   `json:"clusterAccessRoles,omitempty"`
	VirtualClusterRoles []VirtualClusterRole  `json:"virtualClusterRoles,omitempty"`
}

type UserPermissionsRole struct {
	ClusterRole string              `json:"clusterRole,omitempty"`
	Role        string              `json:"role,omitempty"`
	Namespace   string              `json:"namespace,omitempty"`
	Rules       []rbacv1.PolicyRule `json:"rules,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	DisplayName       string                         `json:"displayName,omitempty"`
	Username          string                         `json:"username,omitempty"`
	Password          string                         `json:"password,omitempty"`
	CurrentPassword   string                         `json:"currentPassword,omitempty"`
	Email             string                         `json:"email,omitempty"`
	Icon              *string                        `json:"icon,omitempty"`
	Custom            string                         `json:"custom,omitempty"`
	Secrets           *map[string]*UserProfileSecret `json:"secrets,omitempty"`
}

type UserProfileSecret struct {
	Type string `json:"type,omitempty"`
	Data string `json:"data,omitempty"`
}

type UserSpec struct {
	storagev1.UserSpec `json:",inline"`
}

type UserStatus struct {
	storagev1.UserStatus `json:",inline"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterAccessKey struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	AccessKey         string `json:"accessKey,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterExternalDatabase struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualClusterExternalDatabaseSpec   `json:"spec,omitempty"`
	Status            VirtualClusterExternalDatabaseStatus `json:"status,omitempty"`
}

type VirtualClusterExternalDatabaseSpec struct {
	Connector string `json:"connector,omitempty"`
}

type VirtualClusterExternalDatabaseStatus struct {
	DataSource string `json:"dataSource,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualClusterInstanceSpec   `json:"spec,omitempty"`
	Status            VirtualClusterInstanceStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceKubeConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualClusterInstanceKubeConfigSpec   `json:"spec,omitempty"`
	Status            VirtualClusterInstanceKubeConfigStatus `json:"status,omitempty"`
}

type VirtualClusterInstanceKubeConfigSpec struct {
	CertificateTTL *int32 `json:"certificateTTL,omitempty"`
}

type VirtualClusterInstanceKubeConfigStatus struct {
	KubeConfig string `json:"kubeConfig,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceLog struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
}

type VirtualClusterInstanceSpec struct {
	storagev1.VirtualClusterInstanceSpec `json:",inline"`
}

type VirtualClusterInstanceStatus struct {
	storagev1.VirtualClusterInstanceStatus `json:",inline"`
	SleepModeConfig                        *clusterv1.SleepModeConfig `json:"sleepModeConfig,omitempty"`
	CanUse                                 bool                       `json:"canUse,omitempty"`
	CanUpdate                              bool                       `json:"canUpdate,omitempty"`
	Online                                 bool                       `json:"online,omitempty"`
}

type VirtualClusterRole struct {
	ObjectName  `json:",inline"`
	Role        string      `json:"role,omitempty"`
	AssignedVia AssignedVia `json:"assignedVia,omitempty"`
}

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterSchema struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualClusterSchemaSpec   `json:"spec,omitempty"`
	Status            VirtualClusterSchemaStatus `json:"status,omitempty"`
}

type VirtualClusterSchemaSpec struct {
	Version string `json:"version,omitempty"`
}

type VirtualClusterSchemaStatus struct {
	Schema        string `json:"schema,omitempty"`
	DefaultValues string `json:"defaultValues,omitempty"`
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualClusterTemplateSpec   `json:"spec,omitempty"`
	Status            VirtualClusterTemplateStatus `json:"status,omitempty"`
}

type VirtualClusterTemplateSpec struct {
	storagev1.VirtualClusterTemplateSpec `json:",inline"`
}

type VirtualClusterTemplateStatus struct {
	storagev1.VirtualClusterTemplateStatus `json:",inline"`
	Apps                                   []*storagev1.EntityInfo `json:"apps,omitempty"`
}

// AgentAuditEvent Functions and Structs
//
// +k8s:deepcopy-gen=false
type AgentAuditEventStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AgentAuditEventStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AgentAuditEventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AgentAuditEvent `json:"items"`
}

func (AgentAuditEvent) NewStatus() interface{} {
	return AgentAuditEventStatus{}
}

func (pc *AgentAuditEvent) GetStatus() interface{} {
	return pc.Status
}

func (pc *AgentAuditEvent) SetStatus(s interface{}) {
	pc.Status = s.(AgentAuditEventStatus)
}

func (pc *AgentAuditEvent) GetSpec() interface{} {
	return pc.Spec
}

func (pc *AgentAuditEvent) SetSpec(s interface{}) {
	pc.Spec = s.(AgentAuditEventSpec)
}

func (pc *AgentAuditEvent) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *AgentAuditEvent) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc AgentAuditEvent) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store AgentAuditEvent.
// +k8s:deepcopy-gen=false
type AgentAuditEventRegistry interface {
	ListAgentAuditEvents(ctx context.Context, options *internalversion.ListOptions) (*AgentAuditEventList, error)
	GetAgentAuditEvent(ctx context.Context, id string, options *metav1.GetOptions) (*AgentAuditEvent, error)
	CreateAgentAuditEvent(ctx context.Context, id *AgentAuditEvent) (*AgentAuditEvent, error)
	UpdateAgentAuditEvent(ctx context.Context, id *AgentAuditEvent) (*AgentAuditEvent, error)
	DeleteAgentAuditEvent(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAgentAuditEventRegistry(sp builders.StandardStorageProvider) AgentAuditEventRegistry {
	return &storageAgentAuditEvent{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAgentAuditEvent struct {
	builders.StandardStorageProvider
}

func (s *storageAgentAuditEvent) ListAgentAuditEvents(ctx context.Context, options *internalversion.ListOptions) (*AgentAuditEventList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEventList), err
}

func (s *storageAgentAuditEvent) GetAgentAuditEvent(ctx context.Context, id string, options *metav1.GetOptions) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) CreateAgentAuditEvent(ctx context.Context, object *AgentAuditEvent) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) UpdateAgentAuditEvent(ctx context.Context, object *AgentAuditEvent) (*AgentAuditEvent, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*AgentAuditEvent), nil
}

func (s *storageAgentAuditEvent) DeleteAgentAuditEvent(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Announcement Functions and Structs
//
// +k8s:deepcopy-gen=false
type AnnouncementStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AnnouncementStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AnnouncementList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Announcement `json:"items"`
}

func (Announcement) NewStatus() interface{} {
	return AnnouncementStatus{}
}

func (pc *Announcement) GetStatus() interface{} {
	return pc.Status
}

func (pc *Announcement) SetStatus(s interface{}) {
	pc.Status = s.(AnnouncementStatus)
}

func (pc *Announcement) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Announcement) SetSpec(s interface{}) {
	pc.Spec = s.(AnnouncementSpec)
}

func (pc *Announcement) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Announcement) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Announcement) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Announcement.
// +k8s:deepcopy-gen=false
type AnnouncementRegistry interface {
	ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error)
	GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error)
	CreateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	UpdateAnnouncement(ctx context.Context, id *Announcement) (*Announcement, error)
	DeleteAnnouncement(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAnnouncementRegistry(sp builders.StandardStorageProvider) AnnouncementRegistry {
	return &storageAnnouncement{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAnnouncement struct {
	builders.StandardStorageProvider
}

func (s *storageAnnouncement) ListAnnouncements(ctx context.Context, options *internalversion.ListOptions) (*AnnouncementList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AnnouncementList), err
}

func (s *storageAnnouncement) GetAnnouncement(ctx context.Context, id string, options *metav1.GetOptions) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) CreateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) UpdateAnnouncement(ctx context.Context, object *Announcement) (*Announcement, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Announcement), nil
}

func (s *storageAnnouncement) DeleteAnnouncement(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// App Functions and Structs
//
// +k8s:deepcopy-gen=false
type AppStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AppStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AppList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []App `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AppCredentialsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AppCredentials `json:"items"`
}

func (App) NewStatus() interface{} {
	return AppStatus{}
}

func (pc *App) GetStatus() interface{} {
	return pc.Status
}

func (pc *App) SetStatus(s interface{}) {
	pc.Status = s.(AppStatus)
}

func (pc *App) GetSpec() interface{} {
	return pc.Spec
}

func (pc *App) SetSpec(s interface{}) {
	pc.Spec = s.(AppSpec)
}

func (pc *App) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *App) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc App) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store App.
// +k8s:deepcopy-gen=false
type AppRegistry interface {
	ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error)
	GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error)
	CreateApp(ctx context.Context, id *App) (*App, error)
	UpdateApp(ctx context.Context, id *App) (*App, error)
	DeleteApp(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAppRegistry(sp builders.StandardStorageProvider) AppRegistry {
	return &storageApp{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageApp struct {
	builders.StandardStorageProvider
}

func (s *storageApp) ListApps(ctx context.Context, options *internalversion.ListOptions) (*AppList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AppList), err
}

func (s *storageApp) GetApp(ctx context.Context, id string, options *metav1.GetOptions) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) CreateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) UpdateApp(ctx context.Context, object *App) (*App, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*App), nil
}

func (s *storageApp) DeleteApp(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Backup Functions and Structs
//
// +k8s:deepcopy-gen=false
type BackupStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type BackupStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type BackupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Backup `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type BackupApplyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupApply `json:"items"`
}

func (Backup) NewStatus() interface{} {
	return BackupStatus{}
}

func (pc *Backup) GetStatus() interface{} {
	return pc.Status
}

func (pc *Backup) SetStatus(s interface{}) {
	pc.Status = s.(BackupStatus)
}

func (pc *Backup) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Backup) SetSpec(s interface{}) {
	pc.Spec = s.(BackupSpec)
}

func (pc *Backup) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Backup) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Backup) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Backup.
// +k8s:deepcopy-gen=false
type BackupRegistry interface {
	ListBackups(ctx context.Context, options *internalversion.ListOptions) (*BackupList, error)
	GetBackup(ctx context.Context, id string, options *metav1.GetOptions) (*Backup, error)
	CreateBackup(ctx context.Context, id *Backup) (*Backup, error)
	UpdateBackup(ctx context.Context, id *Backup) (*Backup, error)
	DeleteBackup(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewBackupRegistry(sp builders.StandardStorageProvider) BackupRegistry {
	return &storageBackup{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageBackup struct {
	builders.StandardStorageProvider
}

func (s *storageBackup) ListBackups(ctx context.Context, options *internalversion.ListOptions) (*BackupList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*BackupList), err
}

func (s *storageBackup) GetBackup(ctx context.Context, id string, options *metav1.GetOptions) (*Backup, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Backup), nil
}

func (s *storageBackup) CreateBackup(ctx context.Context, object *Backup) (*Backup, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Backup), nil
}

func (s *storageBackup) UpdateBackup(ctx context.Context, object *Backup) (*Backup, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Backup), nil
}

func (s *storageBackup) DeleteBackup(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Cluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccessKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterAccessKey `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAgentConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterAgentConfig `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterChartsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterCharts `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterDomainList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterDomain `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMemberAccessList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterMemberAccess `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterMembersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterMembers `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterResetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterReset `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterVirtualClusterDefaultsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterVirtualClusterDefaults `json:"items"`
}

func (Cluster) NewStatus() interface{} {
	return ClusterStatus{}
}

func (pc *Cluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *Cluster) SetStatus(s interface{}) {
	pc.Status = s.(ClusterStatus)
}

func (pc *Cluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Cluster) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterSpec)
}

func (pc *Cluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Cluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Cluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Cluster.
// +k8s:deepcopy-gen=false
type ClusterRegistry interface {
	ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error)
	GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error)
	CreateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	UpdateCluster(ctx context.Context, id *Cluster) (*Cluster, error)
	DeleteCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRegistry(sp builders.StandardStorageProvider) ClusterRegistry {
	return &storageCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCluster struct {
	builders.StandardStorageProvider
}

func (s *storageCluster) ListClusters(ctx context.Context, options *internalversion.ListOptions) (*ClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterList), err
}

func (s *storageCluster) GetCluster(ctx context.Context, id string, options *metav1.GetOptions) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) CreateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) UpdateCluster(ctx context.Context, object *Cluster) (*Cluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Cluster), nil
}

func (s *storageCluster) DeleteCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ClusterAccess Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterAccessStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterAccessStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterAccessList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterAccess `json:"items"`
}

func (ClusterAccess) NewStatus() interface{} {
	return ClusterAccessStatus{}
}

func (pc *ClusterAccess) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterAccess) SetStatus(s interface{}) {
	pc.Status = s.(ClusterAccessStatus)
}

func (pc *ClusterAccess) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterAccess) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterAccessSpec)
}

func (pc *ClusterAccess) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterAccess) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterAccess) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterAccess.
// +k8s:deepcopy-gen=false
type ClusterAccessRegistry interface {
	ListClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccessList, error)
	GetClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccess, error)
	CreateClusterAccess(ctx context.Context, id *ClusterAccess) (*ClusterAccess, error)
	UpdateClusterAccess(ctx context.Context, id *ClusterAccess) (*ClusterAccess, error)
	DeleteClusterAccess(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterAccessRegistry(sp builders.StandardStorageProvider) ClusterAccessRegistry {
	return &storageClusterAccess{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterAccess struct {
	builders.StandardStorageProvider
}

func (s *storageClusterAccess) ListClusterAccesss(ctx context.Context, options *internalversion.ListOptions) (*ClusterAccessList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccessList), err
}

func (s *storageClusterAccess) GetClusterAccess(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) CreateClusterAccess(ctx context.Context, object *ClusterAccess) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) UpdateClusterAccess(ctx context.Context, object *ClusterAccess) (*ClusterAccess, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterAccess), nil
}

func (s *storageClusterAccess) DeleteClusterAccess(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ClusterRoleTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type ClusterRoleTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ClusterRoleTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ClusterRoleTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterRoleTemplate `json:"items"`
}

func (ClusterRoleTemplate) NewStatus() interface{} {
	return ClusterRoleTemplateStatus{}
}

func (pc *ClusterRoleTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *ClusterRoleTemplate) SetStatus(s interface{}) {
	pc.Status = s.(ClusterRoleTemplateStatus)
}

func (pc *ClusterRoleTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ClusterRoleTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(ClusterRoleTemplateSpec)
}

func (pc *ClusterRoleTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ClusterRoleTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ClusterRoleTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ClusterRoleTemplate.
// +k8s:deepcopy-gen=false
type ClusterRoleTemplateRegistry interface {
	ListClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleTemplateList, error)
	GetClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRoleTemplate, error)
	CreateClusterRoleTemplate(ctx context.Context, id *ClusterRoleTemplate) (*ClusterRoleTemplate, error)
	UpdateClusterRoleTemplate(ctx context.Context, id *ClusterRoleTemplate) (*ClusterRoleTemplate, error)
	DeleteClusterRoleTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewClusterRoleTemplateRegistry(sp builders.StandardStorageProvider) ClusterRoleTemplateRegistry {
	return &storageClusterRoleTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageClusterRoleTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageClusterRoleTemplate) ListClusterRoleTemplates(ctx context.Context, options *internalversion.ListOptions) (*ClusterRoleTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplateList), err
}

func (s *storageClusterRoleTemplate) GetClusterRoleTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) CreateClusterRoleTemplate(ctx context.Context, object *ClusterRoleTemplate) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) UpdateClusterRoleTemplate(ctx context.Context, object *ClusterRoleTemplate) (*ClusterRoleTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ClusterRoleTemplate), nil
}

func (s *storageClusterRoleTemplate) DeleteClusterRoleTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Config Functions and Structs
//
// +k8s:deepcopy-gen=false
type ConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Config `json:"items"`
}

func (Config) NewStatus() interface{} {
	return ConfigStatus{}
}

func (pc *Config) GetStatus() interface{} {
	return pc.Status
}

func (pc *Config) SetStatus(s interface{}) {
	pc.Status = s.(ConfigStatus)
}

func (pc *Config) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Config) SetSpec(s interface{}) {
	pc.Spec = s.(ConfigSpec)
}

func (pc *Config) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Config) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Config) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Config.
// +k8s:deepcopy-gen=false
type ConfigRegistry interface {
	ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error)
	GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error)
	CreateConfig(ctx context.Context, id *Config) (*Config, error)
	UpdateConfig(ctx context.Context, id *Config) (*Config, error)
	DeleteConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewConfigRegistry(sp builders.StandardStorageProvider) ConfigRegistry {
	return &storageConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageConfig struct {
	builders.StandardStorageProvider
}

func (s *storageConfig) ListConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConfigList), err
}

func (s *storageConfig) GetConfig(ctx context.Context, id string, options *metav1.GetOptions) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) CreateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) UpdateConfig(ctx context.Context, object *Config) (*Config, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Config), nil
}

func (s *storageConfig) DeleteConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ConvertVirtualClusterConfig Functions and Structs
//
// +k8s:deepcopy-gen=false
type ConvertVirtualClusterConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ConvertVirtualClusterConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ConvertVirtualClusterConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ConvertVirtualClusterConfig `json:"items"`
}

func (ConvertVirtualClusterConfig) NewStatus() interface{} {
	return ConvertVirtualClusterConfigStatus{}
}

func (pc *ConvertVirtualClusterConfig) GetStatus() interface{} {
	return pc.Status
}

func (pc *ConvertVirtualClusterConfig) SetStatus(s interface{}) {
	pc.Status = s.(ConvertVirtualClusterConfigStatus)
}

func (pc *ConvertVirtualClusterConfig) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ConvertVirtualClusterConfig) SetSpec(s interface{}) {
	pc.Spec = s.(ConvertVirtualClusterConfigSpec)
}

func (pc *ConvertVirtualClusterConfig) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ConvertVirtualClusterConfig) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ConvertVirtualClusterConfig) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ConvertVirtualClusterConfig.
// +k8s:deepcopy-gen=false
type ConvertVirtualClusterConfigRegistry interface {
	ListConvertVirtualClusterConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConvertVirtualClusterConfigList, error)
	GetConvertVirtualClusterConfig(ctx context.Context, id string, options *metav1.GetOptions) (*ConvertVirtualClusterConfig, error)
	CreateConvertVirtualClusterConfig(ctx context.Context, id *ConvertVirtualClusterConfig) (*ConvertVirtualClusterConfig, error)
	UpdateConvertVirtualClusterConfig(ctx context.Context, id *ConvertVirtualClusterConfig) (*ConvertVirtualClusterConfig, error)
	DeleteConvertVirtualClusterConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewConvertVirtualClusterConfigRegistry(sp builders.StandardStorageProvider) ConvertVirtualClusterConfigRegistry {
	return &storageConvertVirtualClusterConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageConvertVirtualClusterConfig struct {
	builders.StandardStorageProvider
}

func (s *storageConvertVirtualClusterConfig) ListConvertVirtualClusterConfigs(ctx context.Context, options *internalversion.ListOptions) (*ConvertVirtualClusterConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConvertVirtualClusterConfigList), err
}

func (s *storageConvertVirtualClusterConfig) GetConvertVirtualClusterConfig(ctx context.Context, id string, options *metav1.GetOptions) (*ConvertVirtualClusterConfig, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ConvertVirtualClusterConfig), nil
}

func (s *storageConvertVirtualClusterConfig) CreateConvertVirtualClusterConfig(ctx context.Context, object *ConvertVirtualClusterConfig) (*ConvertVirtualClusterConfig, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ConvertVirtualClusterConfig), nil
}

func (s *storageConvertVirtualClusterConfig) UpdateConvertVirtualClusterConfig(ctx context.Context, object *ConvertVirtualClusterConfig) (*ConvertVirtualClusterConfig, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ConvertVirtualClusterConfig), nil
}

func (s *storageConvertVirtualClusterConfig) DeleteConvertVirtualClusterConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodEnvironmentTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodEnvironmentTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodEnvironmentTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodEnvironmentTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodEnvironmentTemplate `json:"items"`
}

func (DevPodEnvironmentTemplate) NewStatus() interface{} {
	return DevPodEnvironmentTemplateStatus{}
}

func (pc *DevPodEnvironmentTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodEnvironmentTemplate) SetStatus(s interface{}) {
	pc.Status = s.(DevPodEnvironmentTemplateStatus)
}

func (pc *DevPodEnvironmentTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodEnvironmentTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodEnvironmentTemplateSpec)
}

func (pc *DevPodEnvironmentTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodEnvironmentTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodEnvironmentTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodEnvironmentTemplate.
// +k8s:deepcopy-gen=false
type DevPodEnvironmentTemplateRegistry interface {
	ListDevPodEnvironmentTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodEnvironmentTemplateList, error)
	GetDevPodEnvironmentTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodEnvironmentTemplate, error)
	CreateDevPodEnvironmentTemplate(ctx context.Context, id *DevPodEnvironmentTemplate) (*DevPodEnvironmentTemplate, error)
	UpdateDevPodEnvironmentTemplate(ctx context.Context, id *DevPodEnvironmentTemplate) (*DevPodEnvironmentTemplate, error)
	DeleteDevPodEnvironmentTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodEnvironmentTemplateRegistry(sp builders.StandardStorageProvider) DevPodEnvironmentTemplateRegistry {
	return &storageDevPodEnvironmentTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodEnvironmentTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodEnvironmentTemplate) ListDevPodEnvironmentTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodEnvironmentTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodEnvironmentTemplateList), err
}

func (s *storageDevPodEnvironmentTemplate) GetDevPodEnvironmentTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodEnvironmentTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodEnvironmentTemplate), nil
}

func (s *storageDevPodEnvironmentTemplate) CreateDevPodEnvironmentTemplate(ctx context.Context, object *DevPodEnvironmentTemplate) (*DevPodEnvironmentTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodEnvironmentTemplate), nil
}

func (s *storageDevPodEnvironmentTemplate) UpdateDevPodEnvironmentTemplate(ctx context.Context, object *DevPodEnvironmentTemplate) (*DevPodEnvironmentTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodEnvironmentTemplate), nil
}

func (s *storageDevPodEnvironmentTemplate) DeleteDevPodEnvironmentTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodWorkspaceInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstance `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceCancelList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceCancel `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceDownloadList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceDownload `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceLogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceLog `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceStopList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceStop `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceTasksList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceTasks `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceTroubleshootList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceTroubleshoot `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceInstanceUpList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceInstanceUp `json:"items"`
}

func (DevPodWorkspaceInstance) NewStatus() interface{} {
	return DevPodWorkspaceInstanceStatus{}
}

func (pc *DevPodWorkspaceInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodWorkspaceInstance) SetStatus(s interface{}) {
	pc.Status = s.(DevPodWorkspaceInstanceStatus)
}

func (pc *DevPodWorkspaceInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodWorkspaceInstance) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodWorkspaceInstanceSpec)
}

func (pc *DevPodWorkspaceInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodWorkspaceInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodWorkspaceInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodWorkspaceInstance.
// +k8s:deepcopy-gen=false
type DevPodWorkspaceInstanceRegistry interface {
	ListDevPodWorkspaceInstances(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceInstanceList, error)
	GetDevPodWorkspaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceInstance, error)
	CreateDevPodWorkspaceInstance(ctx context.Context, id *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error)
	UpdateDevPodWorkspaceInstance(ctx context.Context, id *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error)
	DeleteDevPodWorkspaceInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodWorkspaceInstanceRegistry(sp builders.StandardStorageProvider) DevPodWorkspaceInstanceRegistry {
	return &storageDevPodWorkspaceInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodWorkspaceInstance struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodWorkspaceInstance) ListDevPodWorkspaceInstances(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstanceList), err
}

func (s *storageDevPodWorkspaceInstance) GetDevPodWorkspaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) CreateDevPodWorkspaceInstance(ctx context.Context, object *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) UpdateDevPodWorkspaceInstance(ctx context.Context, object *DevPodWorkspaceInstance) (*DevPodWorkspaceInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceInstance), nil
}

func (s *storageDevPodWorkspaceInstance) DeleteDevPodWorkspaceInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodWorkspacePreset Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodWorkspacePresetStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodWorkspacePresetStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspacePresetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspacePreset `json:"items"`
}

func (DevPodWorkspacePreset) NewStatus() interface{} {
	return DevPodWorkspacePresetStatus{}
}

func (pc *DevPodWorkspacePreset) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodWorkspacePreset) SetStatus(s interface{}) {
	pc.Status = s.(DevPodWorkspacePresetStatus)
}

func (pc *DevPodWorkspacePreset) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodWorkspacePreset) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodWorkspacePresetSpec)
}

func (pc *DevPodWorkspacePreset) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodWorkspacePreset) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodWorkspacePreset) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodWorkspacePreset.
// +k8s:deepcopy-gen=false
type DevPodWorkspacePresetRegistry interface {
	ListDevPodWorkspacePresets(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspacePresetList, error)
	GetDevPodWorkspacePreset(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspacePreset, error)
	CreateDevPodWorkspacePreset(ctx context.Context, id *DevPodWorkspacePreset) (*DevPodWorkspacePreset, error)
	UpdateDevPodWorkspacePreset(ctx context.Context, id *DevPodWorkspacePreset) (*DevPodWorkspacePreset, error)
	DeleteDevPodWorkspacePreset(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodWorkspacePresetRegistry(sp builders.StandardStorageProvider) DevPodWorkspacePresetRegistry {
	return &storageDevPodWorkspacePreset{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodWorkspacePreset struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodWorkspacePreset) ListDevPodWorkspacePresets(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspacePresetList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspacePresetList), err
}

func (s *storageDevPodWorkspacePreset) GetDevPodWorkspacePreset(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspacePreset, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspacePreset), nil
}

func (s *storageDevPodWorkspacePreset) CreateDevPodWorkspacePreset(ctx context.Context, object *DevPodWorkspacePreset) (*DevPodWorkspacePreset, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspacePreset), nil
}

func (s *storageDevPodWorkspacePreset) UpdateDevPodWorkspacePreset(ctx context.Context, object *DevPodWorkspacePreset) (*DevPodWorkspacePreset, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspacePreset), nil
}

func (s *storageDevPodWorkspacePreset) DeleteDevPodWorkspacePreset(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DevPodWorkspaceTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DevPodWorkspaceTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DevPodWorkspaceTemplate `json:"items"`
}

func (DevPodWorkspaceTemplate) NewStatus() interface{} {
	return DevPodWorkspaceTemplateStatus{}
}

func (pc *DevPodWorkspaceTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *DevPodWorkspaceTemplate) SetStatus(s interface{}) {
	pc.Status = s.(DevPodWorkspaceTemplateStatus)
}

func (pc *DevPodWorkspaceTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DevPodWorkspaceTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(DevPodWorkspaceTemplateSpec)
}

func (pc *DevPodWorkspaceTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DevPodWorkspaceTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DevPodWorkspaceTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DevPodWorkspaceTemplate.
// +k8s:deepcopy-gen=false
type DevPodWorkspaceTemplateRegistry interface {
	ListDevPodWorkspaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceTemplateList, error)
	GetDevPodWorkspaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceTemplate, error)
	CreateDevPodWorkspaceTemplate(ctx context.Context, id *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error)
	UpdateDevPodWorkspaceTemplate(ctx context.Context, id *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error)
	DeleteDevPodWorkspaceTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDevPodWorkspaceTemplateRegistry(sp builders.StandardStorageProvider) DevPodWorkspaceTemplateRegistry {
	return &storageDevPodWorkspaceTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDevPodWorkspaceTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageDevPodWorkspaceTemplate) ListDevPodWorkspaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*DevPodWorkspaceTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplateList), err
}

func (s *storageDevPodWorkspaceTemplate) GetDevPodWorkspaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) CreateDevPodWorkspaceTemplate(ctx context.Context, object *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) UpdateDevPodWorkspaceTemplate(ctx context.Context, object *DevPodWorkspaceTemplate) (*DevPodWorkspaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DevPodWorkspaceTemplate), nil
}

func (s *storageDevPodWorkspaceTemplate) DeleteDevPodWorkspaceTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// DirectClusterEndpointToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type DirectClusterEndpointTokenList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DirectClusterEndpointToken `json:"items"`
}

func (DirectClusterEndpointToken) NewStatus() interface{} {
	return DirectClusterEndpointTokenStatus{}
}

func (pc *DirectClusterEndpointToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *DirectClusterEndpointToken) SetStatus(s interface{}) {
	pc.Status = s.(DirectClusterEndpointTokenStatus)
}

func (pc *DirectClusterEndpointToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *DirectClusterEndpointToken) SetSpec(s interface{}) {
	pc.Spec = s.(DirectClusterEndpointTokenSpec)
}

func (pc *DirectClusterEndpointToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *DirectClusterEndpointToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc DirectClusterEndpointToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store DirectClusterEndpointToken.
// +k8s:deepcopy-gen=false
type DirectClusterEndpointTokenRegistry interface {
	ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error)
	GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error)
	CreateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	UpdateDirectClusterEndpointToken(ctx context.Context, id *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error)
	DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewDirectClusterEndpointTokenRegistry(sp builders.StandardStorageProvider) DirectClusterEndpointTokenRegistry {
	return &storageDirectClusterEndpointToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageDirectClusterEndpointToken struct {
	builders.StandardStorageProvider
}

func (s *storageDirectClusterEndpointToken) ListDirectClusterEndpointTokens(ctx context.Context, options *internalversion.ListOptions) (*DirectClusterEndpointTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointTokenList), err
}

func (s *storageDirectClusterEndpointToken) GetDirectClusterEndpointToken(ctx context.Context, id string, options *metav1.GetOptions) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) CreateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) UpdateDirectClusterEndpointToken(ctx context.Context, object *DirectClusterEndpointToken) (*DirectClusterEndpointToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*DirectClusterEndpointToken), nil
}

func (s *storageDirectClusterEndpointToken) DeleteDirectClusterEndpointToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Event Functions and Structs
//
// +k8s:deepcopy-gen=false
type EventStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type EventStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type EventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Event `json:"items"`
}

func (Event) NewStatus() interface{} {
	return EventStatus{}
}

func (pc *Event) GetStatus() interface{} {
	return pc.Status
}

func (pc *Event) SetStatus(s interface{}) {
	pc.Status = s.(EventStatus)
}

func (pc *Event) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Event) SetSpec(s interface{}) {
	pc.Spec = s.(EventSpec)
}

func (pc *Event) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Event) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Event) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Event.
// +k8s:deepcopy-gen=false
type EventRegistry interface {
	ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error)
	GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error)
	CreateEvent(ctx context.Context, id *Event) (*Event, error)
	UpdateEvent(ctx context.Context, id *Event) (*Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewEventRegistry(sp builders.StandardStorageProvider) EventRegistry {
	return &storageEvent{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageEvent struct {
	builders.StandardStorageProvider
}

func (s *storageEvent) ListEvents(ctx context.Context, options *internalversion.ListOptions) (*EventList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*EventList), err
}

func (s *storageEvent) GetEvent(ctx context.Context, id string, options *metav1.GetOptions) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) CreateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) UpdateEvent(ctx context.Context, object *Event) (*Event, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Event), nil
}

func (s *storageEvent) DeleteEvent(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Feature Functions and Structs
//
// +k8s:deepcopy-gen=false
type FeatureStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type FeatureStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type FeatureList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Feature `json:"items"`
}

func (Feature) NewStatus() interface{} {
	return FeatureStatus{}
}

func (pc *Feature) GetStatus() interface{} {
	return pc.Status
}

func (pc *Feature) SetStatus(s interface{}) {
	pc.Status = s.(FeatureStatus)
}

func (pc *Feature) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Feature) SetSpec(s interface{}) {
	pc.Spec = s.(FeatureSpec)
}

func (pc *Feature) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Feature) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Feature) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Feature.
// +k8s:deepcopy-gen=false
type FeatureRegistry interface {
	ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error)
	GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error)
	CreateFeature(ctx context.Context, id *Feature) (*Feature, error)
	UpdateFeature(ctx context.Context, id *Feature) (*Feature, error)
	DeleteFeature(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewFeatureRegistry(sp builders.StandardStorageProvider) FeatureRegistry {
	return &storageFeature{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageFeature struct {
	builders.StandardStorageProvider
}

func (s *storageFeature) ListFeatures(ctx context.Context, options *internalversion.ListOptions) (*FeatureList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*FeatureList), err
}

func (s *storageFeature) GetFeature(ctx context.Context, id string, options *metav1.GetOptions) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) CreateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) UpdateFeature(ctx context.Context, object *Feature) (*Feature, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Feature), nil
}

func (s *storageFeature) DeleteFeature(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// IngressAuthToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type IngressAuthTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type IngressAuthTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type IngressAuthTokenList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IngressAuthToken `json:"items"`
}

func (IngressAuthToken) NewStatus() interface{} {
	return IngressAuthTokenStatus{}
}

func (pc *IngressAuthToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *IngressAuthToken) SetStatus(s interface{}) {
	pc.Status = s.(IngressAuthTokenStatus)
}

func (pc *IngressAuthToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *IngressAuthToken) SetSpec(s interface{}) {
	pc.Spec = s.(IngressAuthTokenSpec)
}

func (pc *IngressAuthToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *IngressAuthToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc IngressAuthToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store IngressAuthToken.
// +k8s:deepcopy-gen=false
type IngressAuthTokenRegistry interface {
	ListIngressAuthTokens(ctx context.Context, options *internalversion.ListOptions) (*IngressAuthTokenList, error)
	GetIngressAuthToken(ctx context.Context, id string, options *metav1.GetOptions) (*IngressAuthToken, error)
	CreateIngressAuthToken(ctx context.Context, id *IngressAuthToken) (*IngressAuthToken, error)
	UpdateIngressAuthToken(ctx context.Context, id *IngressAuthToken) (*IngressAuthToken, error)
	DeleteIngressAuthToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewIngressAuthTokenRegistry(sp builders.StandardStorageProvider) IngressAuthTokenRegistry {
	return &storageIngressAuthToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageIngressAuthToken struct {
	builders.StandardStorageProvider
}

func (s *storageIngressAuthToken) ListIngressAuthTokens(ctx context.Context, options *internalversion.ListOptions) (*IngressAuthTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthTokenList), err
}

func (s *storageIngressAuthToken) GetIngressAuthToken(ctx context.Context, id string, options *metav1.GetOptions) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) CreateIngressAuthToken(ctx context.Context, object *IngressAuthToken) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) UpdateIngressAuthToken(ctx context.Context, object *IngressAuthToken) (*IngressAuthToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*IngressAuthToken), nil
}

func (s *storageIngressAuthToken) DeleteIngressAuthToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Kiosk Functions and Structs
//
// +k8s:deepcopy-gen=false
type KioskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type KioskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type KioskList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Kiosk `json:"items"`
}

func (Kiosk) NewStatus() interface{} {
	return KioskStatus{}
}

func (pc *Kiosk) GetStatus() interface{} {
	return pc.Status
}

func (pc *Kiosk) SetStatus(s interface{}) {
	pc.Status = s.(KioskStatus)
}

func (pc *Kiosk) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Kiosk) SetSpec(s interface{}) {
	pc.Spec = s.(KioskSpec)
}

func (pc *Kiosk) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Kiosk) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Kiosk) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Kiosk.
// +k8s:deepcopy-gen=false
type KioskRegistry interface {
	ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error)
	GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error)
	CreateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	UpdateKiosk(ctx context.Context, id *Kiosk) (*Kiosk, error)
	DeleteKiosk(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewKioskRegistry(sp builders.StandardStorageProvider) KioskRegistry {
	return &storageKiosk{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageKiosk struct {
	builders.StandardStorageProvider
}

func (s *storageKiosk) ListKiosks(ctx context.Context, options *internalversion.ListOptions) (*KioskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*KioskList), err
}

func (s *storageKiosk) GetKiosk(ctx context.Context, id string, options *metav1.GetOptions) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) CreateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) UpdateKiosk(ctx context.Context, object *Kiosk) (*Kiosk, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Kiosk), nil
}

func (s *storageKiosk) DeleteKiosk(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// License Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []License `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseRequestList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LicenseRequest `json:"items"`
}

func (License) NewStatus() interface{} {
	return LicenseStatus{}
}

func (pc *License) GetStatus() interface{} {
	return pc.Status
}

func (pc *License) SetStatus(s interface{}) {
	pc.Status = s.(LicenseStatus)
}

func (pc *License) GetSpec() interface{} {
	return pc.Spec
}

func (pc *License) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseSpec)
}

func (pc *License) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *License) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc License) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store License.
// +k8s:deepcopy-gen=false
type LicenseRegistry interface {
	ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error)
	GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error)
	CreateLicense(ctx context.Context, id *License) (*License, error)
	UpdateLicense(ctx context.Context, id *License) (*License, error)
	DeleteLicense(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseRegistry(sp builders.StandardStorageProvider) LicenseRegistry {
	return &storageLicense{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicense struct {
	builders.StandardStorageProvider
}

func (s *storageLicense) ListLicenses(ctx context.Context, options *internalversion.ListOptions) (*LicenseList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseList), err
}

func (s *storageLicense) GetLicense(ctx context.Context, id string, options *metav1.GetOptions) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) CreateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) UpdateLicense(ctx context.Context, object *License) (*License, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*License), nil
}

func (s *storageLicense) DeleteLicense(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// LicenseToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type LicenseTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LicenseTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LicenseTokenList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LicenseToken `json:"items"`
}

func (LicenseToken) NewStatus() interface{} {
	return LicenseTokenStatus{}
}

func (pc *LicenseToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *LicenseToken) SetStatus(s interface{}) {
	pc.Status = s.(LicenseTokenStatus)
}

func (pc *LicenseToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LicenseToken) SetSpec(s interface{}) {
	pc.Spec = s.(LicenseTokenSpec)
}

func (pc *LicenseToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LicenseToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LicenseToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LicenseToken.
// +k8s:deepcopy-gen=false
type LicenseTokenRegistry interface {
	ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error)
	GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error)
	CreateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	UpdateLicenseToken(ctx context.Context, id *LicenseToken) (*LicenseToken, error)
	DeleteLicenseToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLicenseTokenRegistry(sp builders.StandardStorageProvider) LicenseTokenRegistry {
	return &storageLicenseToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLicenseToken struct {
	builders.StandardStorageProvider
}

func (s *storageLicenseToken) ListLicenseTokens(ctx context.Context, options *internalversion.ListOptions) (*LicenseTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseTokenList), err
}

func (s *storageLicenseToken) GetLicenseToken(ctx context.Context, id string, options *metav1.GetOptions) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) CreateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) UpdateLicenseToken(ctx context.Context, object *LicenseToken) (*LicenseToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LicenseToken), nil
}

func (s *storageLicenseToken) DeleteLicenseToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// LoftUpgrade Functions and Structs
//
// +k8s:deepcopy-gen=false
type LoftUpgradeStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type LoftUpgradeStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type LoftUpgradeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LoftUpgrade `json:"items"`
}

func (LoftUpgrade) NewStatus() interface{} {
	return LoftUpgradeStatus{}
}

func (pc *LoftUpgrade) GetStatus() interface{} {
	return pc.Status
}

func (pc *LoftUpgrade) SetStatus(s interface{}) {
	pc.Status = s.(LoftUpgradeStatus)
}

func (pc *LoftUpgrade) GetSpec() interface{} {
	return pc.Spec
}

func (pc *LoftUpgrade) SetSpec(s interface{}) {
	pc.Spec = s.(LoftUpgradeSpec)
}

func (pc *LoftUpgrade) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *LoftUpgrade) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc LoftUpgrade) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store LoftUpgrade.
// +k8s:deepcopy-gen=false
type LoftUpgradeRegistry interface {
	ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error)
	GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error)
	CreateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	UpdateLoftUpgrade(ctx context.Context, id *LoftUpgrade) (*LoftUpgrade, error)
	DeleteLoftUpgrade(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewLoftUpgradeRegistry(sp builders.StandardStorageProvider) LoftUpgradeRegistry {
	return &storageLoftUpgrade{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageLoftUpgrade struct {
	builders.StandardStorageProvider
}

func (s *storageLoftUpgrade) ListLoftUpgrades(ctx context.Context, options *internalversion.ListOptions) (*LoftUpgradeList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgradeList), err
}

func (s *storageLoftUpgrade) GetLoftUpgrade(ctx context.Context, id string, options *metav1.GetOptions) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) CreateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) UpdateLoftUpgrade(ctx context.Context, object *LoftUpgrade) (*LoftUpgrade, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*LoftUpgrade), nil
}

func (s *storageLoftUpgrade) DeleteLoftUpgrade(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// OIDCClient Functions and Structs
//
// +k8s:deepcopy-gen=false
type OIDCClientStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type OIDCClientStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OIDCClientList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OIDCClient `json:"items"`
}

func (OIDCClient) NewStatus() interface{} {
	return OIDCClientStatus{}
}

func (pc *OIDCClient) GetStatus() interface{} {
	return pc.Status
}

func (pc *OIDCClient) SetStatus(s interface{}) {
	pc.Status = s.(OIDCClientStatus)
}

func (pc *OIDCClient) GetSpec() interface{} {
	return pc.Spec
}

func (pc *OIDCClient) SetSpec(s interface{}) {
	pc.Spec = s.(OIDCClientSpec)
}

func (pc *OIDCClient) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *OIDCClient) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc OIDCClient) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store OIDCClient.
// +k8s:deepcopy-gen=false
type OIDCClientRegistry interface {
	ListOIDCClients(ctx context.Context, options *internalversion.ListOptions) (*OIDCClientList, error)
	GetOIDCClient(ctx context.Context, id string, options *metav1.GetOptions) (*OIDCClient, error)
	CreateOIDCClient(ctx context.Context, id *OIDCClient) (*OIDCClient, error)
	UpdateOIDCClient(ctx context.Context, id *OIDCClient) (*OIDCClient, error)
	DeleteOIDCClient(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewOIDCClientRegistry(sp builders.StandardStorageProvider) OIDCClientRegistry {
	return &storageOIDCClient{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageOIDCClient struct {
	builders.StandardStorageProvider
}

func (s *storageOIDCClient) ListOIDCClients(ctx context.Context, options *internalversion.ListOptions) (*OIDCClientList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OIDCClientList), err
}

func (s *storageOIDCClient) GetOIDCClient(ctx context.Context, id string, options *metav1.GetOptions) (*OIDCClient, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OIDCClient), nil
}

func (s *storageOIDCClient) CreateOIDCClient(ctx context.Context, object *OIDCClient) (*OIDCClient, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OIDCClient), nil
}

func (s *storageOIDCClient) UpdateOIDCClient(ctx context.Context, object *OIDCClient) (*OIDCClient, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OIDCClient), nil
}

func (s *storageOIDCClient) DeleteOIDCClient(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// OwnedAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type OwnedAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type OwnedAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type OwnedAccessKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OwnedAccessKey `json:"items"`
}

func (OwnedAccessKey) NewStatus() interface{} {
	return OwnedAccessKeyStatus{}
}

func (pc *OwnedAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *OwnedAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(OwnedAccessKeyStatus)
}

func (pc *OwnedAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *OwnedAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(OwnedAccessKeySpec)
}

func (pc *OwnedAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *OwnedAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc OwnedAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store OwnedAccessKey.
// +k8s:deepcopy-gen=false
type OwnedAccessKeyRegistry interface {
	ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error)
	GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error)
	CreateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	UpdateOwnedAccessKey(ctx context.Context, id *OwnedAccessKey) (*OwnedAccessKey, error)
	DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewOwnedAccessKeyRegistry(sp builders.StandardStorageProvider) OwnedAccessKeyRegistry {
	return &storageOwnedAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageOwnedAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageOwnedAccessKey) ListOwnedAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*OwnedAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKeyList), err
}

func (s *storageOwnedAccessKey) GetOwnedAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) CreateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) UpdateOwnedAccessKey(ctx context.Context, object *OwnedAccessKey) (*OwnedAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*OwnedAccessKey), nil
}

func (s *storageOwnedAccessKey) DeleteOwnedAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Project Functions and Structs
//
// +k8s:deepcopy-gen=false
type ProjectStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ProjectStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Project `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartInfoList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectChartInfo `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectChartsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectCharts `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectClustersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectClusters `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectImportSpaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectImportSpace `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMembersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectMembers `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateSpaceInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectMigrateSpaceInstance `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectMigrateVirtualClusterInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectMigrateVirtualClusterInstance `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectTemplatesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectTemplates `json:"items"`
}

func (Project) NewStatus() interface{} {
	return ProjectStatus{}
}

func (pc *Project) GetStatus() interface{} {
	return pc.Status
}

func (pc *Project) SetStatus(s interface{}) {
	pc.Status = s.(ProjectStatus)
}

func (pc *Project) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Project) SetSpec(s interface{}) {
	pc.Spec = s.(ProjectSpec)
}

func (pc *Project) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Project) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Project) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Project.
// +k8s:deepcopy-gen=false
type ProjectRegistry interface {
	ListProjects(ctx context.Context, options *internalversion.ListOptions) (*ProjectList, error)
	GetProject(ctx context.Context, id string, options *metav1.GetOptions) (*Project, error)
	CreateProject(ctx context.Context, id *Project) (*Project, error)
	UpdateProject(ctx context.Context, id *Project) (*Project, error)
	DeleteProject(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewProjectRegistry(sp builders.StandardStorageProvider) ProjectRegistry {
	return &storageProject{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageProject struct {
	builders.StandardStorageProvider
}

func (s *storageProject) ListProjects(ctx context.Context, options *internalversion.ListOptions) (*ProjectList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectList), err
}

func (s *storageProject) GetProject(ctx context.Context, id string, options *metav1.GetOptions) (*Project, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) CreateProject(ctx context.Context, object *Project) (*Project, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) UpdateProject(ctx context.Context, object *Project) (*Project, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Project), nil
}

func (s *storageProject) DeleteProject(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ProjectSecret Functions and Structs
//
// +k8s:deepcopy-gen=false
type ProjectSecretStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ProjectSecretStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ProjectSecretList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProjectSecret `json:"items"`
}

func (ProjectSecret) NewStatus() interface{} {
	return ProjectSecretStatus{}
}

func (pc *ProjectSecret) GetStatus() interface{} {
	return pc.Status
}

func (pc *ProjectSecret) SetStatus(s interface{}) {
	pc.Status = s.(ProjectSecretStatus)
}

func (pc *ProjectSecret) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ProjectSecret) SetSpec(s interface{}) {
	pc.Spec = s.(ProjectSecretSpec)
}

func (pc *ProjectSecret) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ProjectSecret) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ProjectSecret) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ProjectSecret.
// +k8s:deepcopy-gen=false
type ProjectSecretRegistry interface {
	ListProjectSecrets(ctx context.Context, options *internalversion.ListOptions) (*ProjectSecretList, error)
	GetProjectSecret(ctx context.Context, id string, options *metav1.GetOptions) (*ProjectSecret, error)
	CreateProjectSecret(ctx context.Context, id *ProjectSecret) (*ProjectSecret, error)
	UpdateProjectSecret(ctx context.Context, id *ProjectSecret) (*ProjectSecret, error)
	DeleteProjectSecret(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewProjectSecretRegistry(sp builders.StandardStorageProvider) ProjectSecretRegistry {
	return &storageProjectSecret{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageProjectSecret struct {
	builders.StandardStorageProvider
}

func (s *storageProjectSecret) ListProjectSecrets(ctx context.Context, options *internalversion.ListOptions) (*ProjectSecretList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecretList), err
}

func (s *storageProjectSecret) GetProjectSecret(ctx context.Context, id string, options *metav1.GetOptions) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) CreateProjectSecret(ctx context.Context, object *ProjectSecret) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) UpdateProjectSecret(ctx context.Context, object *ProjectSecret) (*ProjectSecret, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ProjectSecret), nil
}

func (s *storageProjectSecret) DeleteProjectSecret(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// RedirectToken Functions and Structs
//
// +k8s:deepcopy-gen=false
type RedirectTokenStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type RedirectTokenStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RedirectTokenList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RedirectToken `json:"items"`
}

func (RedirectToken) NewStatus() interface{} {
	return RedirectTokenStatus{}
}

func (pc *RedirectToken) GetStatus() interface{} {
	return pc.Status
}

func (pc *RedirectToken) SetStatus(s interface{}) {
	pc.Status = s.(RedirectTokenStatus)
}

func (pc *RedirectToken) GetSpec() interface{} {
	return pc.Spec
}

func (pc *RedirectToken) SetSpec(s interface{}) {
	pc.Spec = s.(RedirectTokenSpec)
}

func (pc *RedirectToken) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *RedirectToken) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc RedirectToken) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store RedirectToken.
// +k8s:deepcopy-gen=false
type RedirectTokenRegistry interface {
	ListRedirectTokens(ctx context.Context, options *internalversion.ListOptions) (*RedirectTokenList, error)
	GetRedirectToken(ctx context.Context, id string, options *metav1.GetOptions) (*RedirectToken, error)
	CreateRedirectToken(ctx context.Context, id *RedirectToken) (*RedirectToken, error)
	UpdateRedirectToken(ctx context.Context, id *RedirectToken) (*RedirectToken, error)
	DeleteRedirectToken(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewRedirectTokenRegistry(sp builders.StandardStorageProvider) RedirectTokenRegistry {
	return &storageRedirectToken{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageRedirectToken struct {
	builders.StandardStorageProvider
}

func (s *storageRedirectToken) ListRedirectTokens(ctx context.Context, options *internalversion.ListOptions) (*RedirectTokenList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectTokenList), err
}

func (s *storageRedirectToken) GetRedirectToken(ctx context.Context, id string, options *metav1.GetOptions) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) CreateRedirectToken(ctx context.Context, object *RedirectToken) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) UpdateRedirectToken(ctx context.Context, object *RedirectToken) (*RedirectToken, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RedirectToken), nil
}

func (s *storageRedirectToken) DeleteRedirectToken(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// RegisterVirtualCluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type RegisterVirtualClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type RegisterVirtualClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type RegisterVirtualClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RegisterVirtualCluster `json:"items"`
}

func (RegisterVirtualCluster) NewStatus() interface{} {
	return RegisterVirtualClusterStatus{}
}

func (pc *RegisterVirtualCluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *RegisterVirtualCluster) SetStatus(s interface{}) {
	pc.Status = s.(RegisterVirtualClusterStatus)
}

func (pc *RegisterVirtualCluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *RegisterVirtualCluster) SetSpec(s interface{}) {
	pc.Spec = s.(RegisterVirtualClusterSpec)
}

func (pc *RegisterVirtualCluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *RegisterVirtualCluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc RegisterVirtualCluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store RegisterVirtualCluster.
// +k8s:deepcopy-gen=false
type RegisterVirtualClusterRegistry interface {
	ListRegisterVirtualClusters(ctx context.Context, options *internalversion.ListOptions) (*RegisterVirtualClusterList, error)
	GetRegisterVirtualCluster(ctx context.Context, id string, options *metav1.GetOptions) (*RegisterVirtualCluster, error)
	CreateRegisterVirtualCluster(ctx context.Context, id *RegisterVirtualCluster) (*RegisterVirtualCluster, error)
	UpdateRegisterVirtualCluster(ctx context.Context, id *RegisterVirtualCluster) (*RegisterVirtualCluster, error)
	DeleteRegisterVirtualCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewRegisterVirtualClusterRegistry(sp builders.StandardStorageProvider) RegisterVirtualClusterRegistry {
	return &storageRegisterVirtualCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageRegisterVirtualCluster struct {
	builders.StandardStorageProvider
}

func (s *storageRegisterVirtualCluster) ListRegisterVirtualClusters(ctx context.Context, options *internalversion.ListOptions) (*RegisterVirtualClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RegisterVirtualClusterList), err
}

func (s *storageRegisterVirtualCluster) GetRegisterVirtualCluster(ctx context.Context, id string, options *metav1.GetOptions) (*RegisterVirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*RegisterVirtualCluster), nil
}

func (s *storageRegisterVirtualCluster) CreateRegisterVirtualCluster(ctx context.Context, object *RegisterVirtualCluster) (*RegisterVirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RegisterVirtualCluster), nil
}

func (s *storageRegisterVirtualCluster) UpdateRegisterVirtualCluster(ctx context.Context, object *RegisterVirtualCluster) (*RegisterVirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*RegisterVirtualCluster), nil
}

func (s *storageRegisterVirtualCluster) DeleteRegisterVirtualCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// ResetAccessKey Functions and Structs
//
// +k8s:deepcopy-gen=false
type ResetAccessKeyStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type ResetAccessKeyStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type ResetAccessKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ResetAccessKey `json:"items"`
}

func (ResetAccessKey) NewStatus() interface{} {
	return ResetAccessKeyStatus{}
}

func (pc *ResetAccessKey) GetStatus() interface{} {
	return pc.Status
}

func (pc *ResetAccessKey) SetStatus(s interface{}) {
	pc.Status = s.(ResetAccessKeyStatus)
}

func (pc *ResetAccessKey) GetSpec() interface{} {
	return pc.Spec
}

func (pc *ResetAccessKey) SetSpec(s interface{}) {
	pc.Spec = s.(ResetAccessKeySpec)
}

func (pc *ResetAccessKey) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *ResetAccessKey) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc ResetAccessKey) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store ResetAccessKey.
// +k8s:deepcopy-gen=false
type ResetAccessKeyRegistry interface {
	ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error)
	GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error)
	CreateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	UpdateResetAccessKey(ctx context.Context, id *ResetAccessKey) (*ResetAccessKey, error)
	DeleteResetAccessKey(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewResetAccessKeyRegistry(sp builders.StandardStorageProvider) ResetAccessKeyRegistry {
	return &storageResetAccessKey{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageResetAccessKey struct {
	builders.StandardStorageProvider
}

func (s *storageResetAccessKey) ListResetAccessKeys(ctx context.Context, options *internalversion.ListOptions) (*ResetAccessKeyList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKeyList), err
}

func (s *storageResetAccessKey) GetResetAccessKey(ctx context.Context, id string, options *metav1.GetOptions) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) CreateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) UpdateResetAccessKey(ctx context.Context, object *ResetAccessKey) (*ResetAccessKey, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*ResetAccessKey), nil
}

func (s *storageResetAccessKey) DeleteResetAccessKey(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Self Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Self `json:"items"`
}

func (Self) NewStatus() interface{} {
	return SelfStatus{}
}

func (pc *Self) GetStatus() interface{} {
	return pc.Status
}

func (pc *Self) SetStatus(s interface{}) {
	pc.Status = s.(SelfStatus)
}

func (pc *Self) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Self) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSpec)
}

func (pc *Self) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Self) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Self) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Self.
// +k8s:deepcopy-gen=false
type SelfRegistry interface {
	ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error)
	GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error)
	CreateSelf(ctx context.Context, id *Self) (*Self, error)
	UpdateSelf(ctx context.Context, id *Self) (*Self, error)
	DeleteSelf(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfRegistry(sp builders.StandardStorageProvider) SelfRegistry {
	return &storageSelf{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelf struct {
	builders.StandardStorageProvider
}

func (s *storageSelf) ListSelfs(ctx context.Context, options *internalversion.ListOptions) (*SelfList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfList), err
}

func (s *storageSelf) GetSelf(ctx context.Context, id string, options *metav1.GetOptions) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) CreateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) UpdateSelf(ctx context.Context, object *Self) (*Self, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Self), nil
}

func (s *storageSelf) DeleteSelf(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SelfSubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SelfSubjectAccessReviewList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SelfSubjectAccessReview `json:"items"`
}

func (SelfSubjectAccessReview) NewStatus() interface{} {
	return SelfSubjectAccessReviewStatus{}
}

func (pc *SelfSubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SelfSubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SelfSubjectAccessReviewStatus)
}

func (pc *SelfSubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SelfSubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SelfSubjectAccessReviewSpec)
}

func (pc *SelfSubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SelfSubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SelfSubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SelfSubjectAccessReview.
// +k8s:deepcopy-gen=false
type SelfSubjectAccessReviewRegistry interface {
	ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error)
	GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error)
	CreateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	UpdateSelfSubjectAccessReview(ctx context.Context, id *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error)
	DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSelfSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SelfSubjectAccessReviewRegistry {
	return &storageSelfSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSelfSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSelfSubjectAccessReview) ListSelfSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SelfSubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReviewList), err
}

func (s *storageSelfSubjectAccessReview) GetSelfSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) CreateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) UpdateSelfSubjectAccessReview(ctx context.Context, object *SelfSubjectAccessReview) (*SelfSubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SelfSubjectAccessReview), nil
}

func (s *storageSelfSubjectAccessReview) DeleteSelfSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SharedSecret Functions and Structs
//
// +k8s:deepcopy-gen=false
type SharedSecretStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SharedSecretStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SharedSecretList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SharedSecret `json:"items"`
}

func (SharedSecret) NewStatus() interface{} {
	return SharedSecretStatus{}
}

func (pc *SharedSecret) GetStatus() interface{} {
	return pc.Status
}

func (pc *SharedSecret) SetStatus(s interface{}) {
	pc.Status = s.(SharedSecretStatus)
}

func (pc *SharedSecret) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SharedSecret) SetSpec(s interface{}) {
	pc.Spec = s.(SharedSecretSpec)
}

func (pc *SharedSecret) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SharedSecret) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SharedSecret) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SharedSecret.
// +k8s:deepcopy-gen=false
type SharedSecretRegistry interface {
	ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error)
	GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error)
	CreateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	UpdateSharedSecret(ctx context.Context, id *SharedSecret) (*SharedSecret, error)
	DeleteSharedSecret(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSharedSecretRegistry(sp builders.StandardStorageProvider) SharedSecretRegistry {
	return &storageSharedSecret{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSharedSecret struct {
	builders.StandardStorageProvider
}

func (s *storageSharedSecret) ListSharedSecrets(ctx context.Context, options *internalversion.ListOptions) (*SharedSecretList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecretList), err
}

func (s *storageSharedSecret) GetSharedSecret(ctx context.Context, id string, options *metav1.GetOptions) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) CreateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) UpdateSharedSecret(ctx context.Context, object *SharedSecret) (*SharedSecret, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SharedSecret), nil
}

func (s *storageSharedSecret) DeleteSharedSecret(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SpaceInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SpaceInstance `json:"items"`
}

func (SpaceInstance) NewStatus() interface{} {
	return SpaceInstanceStatus{}
}

func (pc *SpaceInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceInstance) SetStatus(s interface{}) {
	pc.Status = s.(SpaceInstanceStatus)
}

func (pc *SpaceInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceInstance) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceInstanceSpec)
}

func (pc *SpaceInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceInstance.
// +k8s:deepcopy-gen=false
type SpaceInstanceRegistry interface {
	ListSpaceInstances(ctx context.Context, options *internalversion.ListOptions) (*SpaceInstanceList, error)
	GetSpaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceInstance, error)
	CreateSpaceInstance(ctx context.Context, id *SpaceInstance) (*SpaceInstance, error)
	UpdateSpaceInstance(ctx context.Context, id *SpaceInstance) (*SpaceInstance, error)
	DeleteSpaceInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceInstanceRegistry(sp builders.StandardStorageProvider) SpaceInstanceRegistry {
	return &storageSpaceInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceInstance struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceInstance) ListSpaceInstances(ctx context.Context, options *internalversion.ListOptions) (*SpaceInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstanceList), err
}

func (s *storageSpaceInstance) GetSpaceInstance(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) CreateSpaceInstance(ctx context.Context, object *SpaceInstance) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) UpdateSpaceInstance(ctx context.Context, object *SpaceInstance) (*SpaceInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceInstance), nil
}

func (s *storageSpaceInstance) DeleteSpaceInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SpaceTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type SpaceTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SpaceTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SpaceTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SpaceTemplate `json:"items"`
}

func (SpaceTemplate) NewStatus() interface{} {
	return SpaceTemplateStatus{}
}

func (pc *SpaceTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *SpaceTemplate) SetStatus(s interface{}) {
	pc.Status = s.(SpaceTemplateStatus)
}

func (pc *SpaceTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SpaceTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(SpaceTemplateSpec)
}

func (pc *SpaceTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SpaceTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SpaceTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SpaceTemplate.
// +k8s:deepcopy-gen=false
type SpaceTemplateRegistry interface {
	ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error)
	GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error)
	CreateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	UpdateSpaceTemplate(ctx context.Context, id *SpaceTemplate) (*SpaceTemplate, error)
	DeleteSpaceTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSpaceTemplateRegistry(sp builders.StandardStorageProvider) SpaceTemplateRegistry {
	return &storageSpaceTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSpaceTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageSpaceTemplate) ListSpaceTemplates(ctx context.Context, options *internalversion.ListOptions) (*SpaceTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplateList), err
}

func (s *storageSpaceTemplate) GetSpaceTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) CreateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) UpdateSpaceTemplate(ctx context.Context, object *SpaceTemplate) (*SpaceTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SpaceTemplate), nil
}

func (s *storageSpaceTemplate) DeleteSpaceTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// SubjectAccessReview Functions and Structs
//
// +k8s:deepcopy-gen=false
type SubjectAccessReviewStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SubjectAccessReviewStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SubjectAccessReviewList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SubjectAccessReview `json:"items"`
}

func (SubjectAccessReview) NewStatus() interface{} {
	return SubjectAccessReviewStatus{}
}

func (pc *SubjectAccessReview) GetStatus() interface{} {
	return pc.Status
}

func (pc *SubjectAccessReview) SetStatus(s interface{}) {
	pc.Status = s.(SubjectAccessReviewStatus)
}

func (pc *SubjectAccessReview) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SubjectAccessReview) SetSpec(s interface{}) {
	pc.Spec = s.(SubjectAccessReviewSpec)
}

func (pc *SubjectAccessReview) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SubjectAccessReview) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SubjectAccessReview) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SubjectAccessReview.
// +k8s:deepcopy-gen=false
type SubjectAccessReviewRegistry interface {
	ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error)
	GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error)
	CreateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	UpdateSubjectAccessReview(ctx context.Context, id *SubjectAccessReview) (*SubjectAccessReview, error)
	DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSubjectAccessReviewRegistry(sp builders.StandardStorageProvider) SubjectAccessReviewRegistry {
	return &storageSubjectAccessReview{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSubjectAccessReview struct {
	builders.StandardStorageProvider
}

func (s *storageSubjectAccessReview) ListSubjectAccessReviews(ctx context.Context, options *internalversion.ListOptions) (*SubjectAccessReviewList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReviewList), err
}

func (s *storageSubjectAccessReview) GetSubjectAccessReview(ctx context.Context, id string, options *metav1.GetOptions) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) CreateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) UpdateSubjectAccessReview(ctx context.Context, object *SubjectAccessReview) (*SubjectAccessReview, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SubjectAccessReview), nil
}

func (s *storageSubjectAccessReview) DeleteSubjectAccessReview(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Task Functions and Structs
//
// +k8s:deepcopy-gen=false
type TaskStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TaskStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Task `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TaskLogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TaskLog `json:"items"`
}

func (Task) NewStatus() interface{} {
	return TaskStatus{}
}

func (pc *Task) GetStatus() interface{} {
	return pc.Status
}

func (pc *Task) SetStatus(s interface{}) {
	pc.Status = s.(TaskStatus)
}

func (pc *Task) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Task) SetSpec(s interface{}) {
	pc.Spec = s.(TaskSpec)
}

func (pc *Task) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Task) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Task) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Task.
// +k8s:deepcopy-gen=false
type TaskRegistry interface {
	ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error)
	GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error)
	CreateTask(ctx context.Context, id *Task) (*Task, error)
	UpdateTask(ctx context.Context, id *Task) (*Task, error)
	DeleteTask(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTaskRegistry(sp builders.StandardStorageProvider) TaskRegistry {
	return &storageTask{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTask struct {
	builders.StandardStorageProvider
}

func (s *storageTask) ListTasks(ctx context.Context, options *internalversion.ListOptions) (*TaskList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TaskList), err
}

func (s *storageTask) GetTask(ctx context.Context, id string, options *metav1.GetOptions) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) CreateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) UpdateTask(ctx context.Context, object *Task) (*Task, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Task), nil
}

func (s *storageTask) DeleteTask(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// Team Functions and Structs
//
// +k8s:deepcopy-gen=false
type TeamStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TeamStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Team `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamAccessKeysList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TeamAccessKeys `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamClustersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TeamClusters `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamObjectPermissionsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TeamObjectPermissions `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TeamPermissionsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TeamPermissions `json:"items"`
}

func (Team) NewStatus() interface{} {
	return TeamStatus{}
}

func (pc *Team) GetStatus() interface{} {
	return pc.Status
}

func (pc *Team) SetStatus(s interface{}) {
	pc.Status = s.(TeamStatus)
}

func (pc *Team) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Team) SetSpec(s interface{}) {
	pc.Spec = s.(TeamSpec)
}

func (pc *Team) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Team) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Team) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Team.
// +k8s:deepcopy-gen=false
type TeamRegistry interface {
	ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error)
	GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error)
	CreateTeam(ctx context.Context, id *Team) (*Team, error)
	UpdateTeam(ctx context.Context, id *Team) (*Team, error)
	DeleteTeam(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTeamRegistry(sp builders.StandardStorageProvider) TeamRegistry {
	return &storageTeam{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTeam struct {
	builders.StandardStorageProvider
}

func (s *storageTeam) ListTeams(ctx context.Context, options *internalversion.ListOptions) (*TeamList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TeamList), err
}

func (s *storageTeam) GetTeam(ctx context.Context, id string, options *metav1.GetOptions) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) CreateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) UpdateTeam(ctx context.Context, object *Team) (*Team, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Team), nil
}

func (s *storageTeam) DeleteTeam(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// TranslateVClusterResourceName Functions and Structs
//
// +k8s:deepcopy-gen=false
type TranslateVClusterResourceNameStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type TranslateVClusterResourceNameStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type TranslateVClusterResourceNameList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TranslateVClusterResourceName `json:"items"`
}

func (TranslateVClusterResourceName) NewStatus() interface{} {
	return TranslateVClusterResourceNameStatus{}
}

func (pc *TranslateVClusterResourceName) GetStatus() interface{} {
	return pc.Status
}

func (pc *TranslateVClusterResourceName) SetStatus(s interface{}) {
	pc.Status = s.(TranslateVClusterResourceNameStatus)
}

func (pc *TranslateVClusterResourceName) GetSpec() interface{} {
	return pc.Spec
}

func (pc *TranslateVClusterResourceName) SetSpec(s interface{}) {
	pc.Spec = s.(TranslateVClusterResourceNameSpec)
}

func (pc *TranslateVClusterResourceName) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *TranslateVClusterResourceName) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc TranslateVClusterResourceName) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store TranslateVClusterResourceName.
// +k8s:deepcopy-gen=false
type TranslateVClusterResourceNameRegistry interface {
	ListTranslateVClusterResourceNames(ctx context.Context, options *internalversion.ListOptions) (*TranslateVClusterResourceNameList, error)
	GetTranslateVClusterResourceName(ctx context.Context, id string, options *metav1.GetOptions) (*TranslateVClusterResourceName, error)
	CreateTranslateVClusterResourceName(ctx context.Context, id *TranslateVClusterResourceName) (*TranslateVClusterResourceName, error)
	UpdateTranslateVClusterResourceName(ctx context.Context, id *TranslateVClusterResourceName) (*TranslateVClusterResourceName, error)
	DeleteTranslateVClusterResourceName(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewTranslateVClusterResourceNameRegistry(sp builders.StandardStorageProvider) TranslateVClusterResourceNameRegistry {
	return &storageTranslateVClusterResourceName{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageTranslateVClusterResourceName struct {
	builders.StandardStorageProvider
}

func (s *storageTranslateVClusterResourceName) ListTranslateVClusterResourceNames(ctx context.Context, options *internalversion.ListOptions) (*TranslateVClusterResourceNameList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TranslateVClusterResourceNameList), err
}

func (s *storageTranslateVClusterResourceName) GetTranslateVClusterResourceName(ctx context.Context, id string, options *metav1.GetOptions) (*TranslateVClusterResourceName, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*TranslateVClusterResourceName), nil
}

func (s *storageTranslateVClusterResourceName) CreateTranslateVClusterResourceName(ctx context.Context, object *TranslateVClusterResourceName) (*TranslateVClusterResourceName, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*TranslateVClusterResourceName), nil
}

func (s *storageTranslateVClusterResourceName) UpdateTranslateVClusterResourceName(ctx context.Context, object *TranslateVClusterResourceName) (*TranslateVClusterResourceName, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*TranslateVClusterResourceName), nil
}

func (s *storageTranslateVClusterResourceName) DeleteTranslateVClusterResourceName(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// User Functions and Structs
//
// +k8s:deepcopy-gen=false
type UserStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type UserStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []User `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserAccessKeysList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserAccessKeys `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserClustersList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserClusters `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserObjectPermissionsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserObjectPermissions `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserPermissionsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserPermissions `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type UserProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UserProfile `json:"items"`
}

func (User) NewStatus() interface{} {
	return UserStatus{}
}

func (pc *User) GetStatus() interface{} {
	return pc.Status
}

func (pc *User) SetStatus(s interface{}) {
	pc.Status = s.(UserStatus)
}

func (pc *User) GetSpec() interface{} {
	return pc.Spec
}

func (pc *User) SetSpec(s interface{}) {
	pc.Spec = s.(UserSpec)
}

func (pc *User) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *User) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc User) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store User.
// +k8s:deepcopy-gen=false
type UserRegistry interface {
	ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error)
	GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error)
	CreateUser(ctx context.Context, id *User) (*User, error)
	UpdateUser(ctx context.Context, id *User) (*User, error)
	DeleteUser(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewUserRegistry(sp builders.StandardStorageProvider) UserRegistry {
	return &storageUser{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageUser struct {
	builders.StandardStorageProvider
}

func (s *storageUser) ListUsers(ctx context.Context, options *internalversion.ListOptions) (*UserList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*UserList), err
}

func (s *storageUser) GetUser(ctx context.Context, id string, options *metav1.GetOptions) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) CreateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) UpdateUser(ctx context.Context, object *User) (*User, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*User), nil
}

func (s *storageUser) DeleteUser(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// VirtualClusterInstance Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterInstanceStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterInstanceStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterInstance `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterAccessKeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterAccessKey `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterExternalDatabaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterExternalDatabase `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceKubeConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterInstanceKubeConfig `json:"items"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterInstanceLogList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterInstanceLog `json:"items"`
}

func (VirtualClusterInstance) NewStatus() interface{} {
	return VirtualClusterInstanceStatus{}
}

func (pc *VirtualClusterInstance) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterInstance) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterInstanceStatus)
}

func (pc *VirtualClusterInstance) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterInstance) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterInstanceSpec)
}

func (pc *VirtualClusterInstance) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterInstance) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterInstance) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterInstance.
// +k8s:deepcopy-gen=false
type VirtualClusterInstanceRegistry interface {
	ListVirtualClusterInstances(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterInstanceList, error)
	GetVirtualClusterInstance(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterInstance, error)
	CreateVirtualClusterInstance(ctx context.Context, id *VirtualClusterInstance) (*VirtualClusterInstance, error)
	UpdateVirtualClusterInstance(ctx context.Context, id *VirtualClusterInstance) (*VirtualClusterInstance, error)
	DeleteVirtualClusterInstance(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterInstanceRegistry(sp builders.StandardStorageProvider) VirtualClusterInstanceRegistry {
	return &storageVirtualClusterInstance{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterInstance struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterInstance) ListVirtualClusterInstances(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterInstanceList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstanceList), err
}

func (s *storageVirtualClusterInstance) GetVirtualClusterInstance(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) CreateVirtualClusterInstance(ctx context.Context, object *VirtualClusterInstance) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) UpdateVirtualClusterInstance(ctx context.Context, object *VirtualClusterInstance) (*VirtualClusterInstance, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterInstance), nil
}

func (s *storageVirtualClusterInstance) DeleteVirtualClusterInstance(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// VirtualClusterSchema Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterSchemaStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterSchemaStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterSchemaList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterSchema `json:"items"`
}

func (VirtualClusterSchema) NewStatus() interface{} {
	return VirtualClusterSchemaStatus{}
}

func (pc *VirtualClusterSchema) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterSchema) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterSchemaStatus)
}

func (pc *VirtualClusterSchema) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterSchema) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterSchemaSpec)
}

func (pc *VirtualClusterSchema) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterSchema) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterSchema) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterSchema.
// +k8s:deepcopy-gen=false
type VirtualClusterSchemaRegistry interface {
	ListVirtualClusterSchemas(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterSchemaList, error)
	GetVirtualClusterSchema(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterSchema, error)
	CreateVirtualClusterSchema(ctx context.Context, id *VirtualClusterSchema) (*VirtualClusterSchema, error)
	UpdateVirtualClusterSchema(ctx context.Context, id *VirtualClusterSchema) (*VirtualClusterSchema, error)
	DeleteVirtualClusterSchema(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterSchemaRegistry(sp builders.StandardStorageProvider) VirtualClusterSchemaRegistry {
	return &storageVirtualClusterSchema{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterSchema struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterSchema) ListVirtualClusterSchemas(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterSchemaList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterSchemaList), err
}

func (s *storageVirtualClusterSchema) GetVirtualClusterSchema(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterSchema, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterSchema), nil
}

func (s *storageVirtualClusterSchema) CreateVirtualClusterSchema(ctx context.Context, object *VirtualClusterSchema) (*VirtualClusterSchema, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterSchema), nil
}

func (s *storageVirtualClusterSchema) UpdateVirtualClusterSchema(ctx context.Context, object *VirtualClusterSchema) (*VirtualClusterSchema, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterSchema), nil
}

func (s *storageVirtualClusterSchema) DeleteVirtualClusterSchema(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

// VirtualClusterTemplate Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterTemplateStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualClusterTemplate `json:"items"`
}

func (VirtualClusterTemplate) NewStatus() interface{} {
	return VirtualClusterTemplateStatus{}
}

func (pc *VirtualClusterTemplate) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualClusterTemplate) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterTemplateStatus)
}

func (pc *VirtualClusterTemplate) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualClusterTemplate) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterTemplateSpec)
}

func (pc *VirtualClusterTemplate) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualClusterTemplate) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualClusterTemplate) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualClusterTemplate.
// +k8s:deepcopy-gen=false
type VirtualClusterTemplateRegistry interface {
	ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error)
	GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error)
	CreateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	UpdateVirtualClusterTemplate(ctx context.Context, id *VirtualClusterTemplate) (*VirtualClusterTemplate, error)
	DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterTemplateRegistry(sp builders.StandardStorageProvider) VirtualClusterTemplateRegistry {
	return &storageVirtualClusterTemplate{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualClusterTemplate struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualClusterTemplate) ListVirtualClusterTemplates(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterTemplateList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplateList), err
}

func (s *storageVirtualClusterTemplate) GetVirtualClusterTemplate(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) CreateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) UpdateVirtualClusterTemplate(ctx context.Context, object *VirtualClusterTemplate) (*VirtualClusterTemplate, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterTemplate), nil
}

func (s *storageVirtualClusterTemplate) DeleteVirtualClusterTemplate(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}
